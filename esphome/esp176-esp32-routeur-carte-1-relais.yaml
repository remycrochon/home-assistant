# Passage en Regul PID ligne 334 et 400
substitutions:
  device_name: "esp176-esp32-routeur-1r"
  friendly_name: esp176
  adress_ip: "192.168.0.176"
  time_timezone: "Europe/Paris"

  name: jsy194
  current_address: '1'
  current_baud_rate: '38400'
  updates: 0.5s
  modbus_send_wait_time: 100ms
  #modbus_throttle: 50ms #1000ms
  offset_select: '2'  


esphome:
  name: ${device_name}
  on_boot:
    priority: 800
    # Force mode auto et tempok au demarrage
    then: 
      - switch.turn_on: modeauto
      - binary_sensor.template.publish:
          id: temperatureok
          state: ON
      - lambda: id(afstriac).publish_state( 0 );           
 
esp32:
  board: esp32dev
  framework:
    type: arduino
    version: 2.0.11 #2.0.5 2.0.9
    platform_version: 6.4.0 #4.4.0 6.2.0   

wifi:
  networks:
    - ssid: !secret wifi
      password: !secret mdpwifi
  reboot_timeout: 5min

  manual_ip:
    static_ip: ${adress_ip}
    gateway: 192.168.0.254
    subnet: 255.255.255.0

# Enable logging
logger:
  baud_rate: 0
  level: info
# level: none

web_server:
  port: 80
api:
ota:
# Protocole afficheur
i2c:
  sda: GPIO21 
  scl: GPIO22
  scan: True
  id: bus_a

mqtt:
  broker: 192.168.0.37
  username: !secret mqtt_ha_name
  password: !secret mqtt_ha_pw
  #internal_mqtt_default: internal

globals:
   - id: increment
     type: float
     restore_value: no
     initial_value: '0'
   - id: striac
     type: float
     restore_value: yes

# Sonde Temperature Dallas
dallas:
  - pin: GPIO27 #
    update_interval: 60s

external_components:
#  - source: "github://SeByDocKy/myESPhome/"
  - source: mes_composants
    components: [jsy194]
    refresh: 0s

uart:
  - id: uart_0
    tx_pin: 17
    rx_pin: 16 
    baud_rate: ${current_baud_rate}
    stop_bits: 1 
#    debug:
#      direction: BOTH
#      dummy_receiver: false
#      after:
#        timeout: 150ms
#     sequence:
#        - lambda: |-
#            UARTDebug::log_string(direction, bytes);

modbus:
   id: modbus_0
   uart_id: uart_0
   send_wait_time: ${modbus_send_wait_time}

#modbus_controller:
#  - id: jsymk
#    ## the Modbus device addr
#    address: 0x1
#    modbus_id: modbus_0
#    update_interval: 0.75s
#    command_throttle: 50ms
    # setup_priority: -10

binary_sensor:
#Etat de la connection
  - platform: status
    name: "${friendly_name}_Status"

  - platform: template
    name: "${friendly_name} Temp Ok"
    id: temperatureok

  - platform: template
    name: "${friendly_name} Seuil Prod Ok"
    id: seuil_prod_ok

  - platform: homeassistant
    name: "Validation Routeur"
    entity_id: "input_boolean.inter_validation_routeur"
    id: val_routeur

# Input Number
number:
  # Seuil Min/Max sortie triac
  - platform: template
    name: "${friendly_name} P Max"
    id: pmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 50
    max_value: 100
    unit_of_measurement: "%"
    step: 1

  - platform: template
    name: "${friendly_name} P Min"
    id: pmin
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 25
    unit_of_measurement: "%"
    step: 1

# Seuil MAX temperature
  - platform: template
    name: "${friendly_name} T Max"
    id: tmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 75
    unit_of_measurement: "C°"
    step: 0.1

# Coeff Réactivité
  - platform: template
    name: "${friendly_name} Coeff R"
    id: coeff_r
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 1000
    unit_of_measurement: ""
    step: 0.1
# seuil Puissance batteries 
  - platform: template
    name: "${friendly_name} Seuil Pu Batteries"
    id: seuil_pubatt
    optimistic: true
    restore_value: true
    mode: box
    min_value: -2500
    max_value: 0
    unit_of_measurement: "W"
    step: 1

# Coeff Réactivité Puissance Batteries
  - platform: template
    name: "${friendly_name} Coeff R bat"
    id: coeff_rbat
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 1000
    unit_of_measurement: ""
    step: 0.1
# Consigne sur Puissance Batteries
  - platform: template
    name: "${friendly_name} Consigne Pu Batteries"
    id: cons_pubatt
    optimistic: true
    restore_value: true
    mode: box
    min_value: -2500
    max_value: 2500
    unit_of_measurement: "W"
    step: 1
# Consigne sur Puissance Heure Creuses
  - platform: template
    name: "${friendly_name} Consigne Pu Heure Creuse"
    id: cons_puhc
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 8000
    unit_of_measurement: "W"
    step: 1
# seuil Production validation routeur 
  - platform: template
    name: "${friendly_name} Seuil Production Val Routeur"
    id: seuil_prod
    optimistic: true
    restore_value: true
    mode: box
    min_value: 500
    max_value: 3000
    unit_of_measurement: "W"
    step: 1

# regulation PID
# Consigne sur Puissance PID
  - platform: template
    name: "${friendly_name} Consigne Pu PID"
    id: cons_pid
    optimistic: true
    restore_value: true
    mode: box
    min_value: -100
    max_value: 8000
    unit_of_measurement: "W"
    step: 1

  - platform: template
    name: "${friendly_name} Coeff Kp"
    id: kp
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 10
    unit_of_measurement: ""
    step: 0.01

  - platform: template
    name: "${friendly_name} Coeff Ki"
    id: ki
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 10
    unit_of_measurement: ""
    step: 0.01

  - platform: template
    name: "${friendly_name} Coeff Kd"
    id: kd
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 10
    unit_of_measurement: ""
    step: 0.01

sensor:
  - platform: jsy194
    address: ${current_address}
# Voie ECS
    current1:
      name: "${friendly_name} I_ECS JSYMK"
      accuracy_decimals: 2
      id: Itore
      filters:
        - multiply: -1
    voltage1:
      name: ${name}_voltage1
      accuracy_decimals: 2
    power1:
      name: "${friendly_name} P_ECS JSYMK"
      id: puecs
      accuracy_decimals: 2
      filters:
        - multiply: -1      
    frequency1:
      name: ${name}_frequency1
      accuracy_decimals: 2
    power_factor1:
      name: ${name}_power_factor1
      accuracy_decimals: 2
    pos_energy1:
      name: "${friendly_name} Energie ECS Neg JSYMK"
      accuracy_decimals: 1
    neg_energy1:
      name: "${friendly_name} Energie ECS JSYMK"
      accuracy_decimals: 1
# grid
    current2:
      name: ${name}_current2
      accuracy_decimals: 2
#    voltage2:
#      name: ${name}_voltage2
#      accuracy_decimals: 2
    power2:
      name: ${name}_power2
      id: pureseau
      unit_of_measurement: W
      accuracy_decimals: 2
      on_value:
        then:
          - lambda: id(pureseau1).publish_state( id(pureseau).state );
          - lambda: id(calcul_injection_mode_hp).execute();  
#          - lambda: id(pid).execute();  

#          - lambda: |-
#             if (id(hc).state == 2 || id(hc).state == 4 || id(hc).state == 6){
#                id(calcul_injection_mode_hp).execute();
#              } else {
#                id(calcul_injection_mode_hp).execute();
#              }            
  
           
#    frequency2:
#      name: ${name}_frequency2
#      accuracy_decimals: 2
    power_factor2:
      name: ${name}_power_factor2
      accuracy_decimals: 2
    pos_energy2:
      name: ${name}_pos_energy2
      accuracy_decimals: 1
    neg_energy2:
      name: ${name}_neg_energy2
      accuracy_decimals: 1     
    update_interval: ${updates}
    modbus_id: modbus_0
    id: ${name}_id

# Informations WI_FI
  - platform: wifi_signal # Affiche le signal WiFi strength/RSSI en dB
    name: "${friendly_name} WiFi Signal dB"
    update_interval: 60s

############### TEMPLATE  ######################"
# Affichage dans HA et sur l'afficheur
  - platform: template
    name: "${friendly_name} Pu Reseau"
    id: pureseau1
    unit_of_measurement: "W"
    state_class: "measurement"  
 
  - platform: template
    name: "${friendly_name} Increment"
    id: afincrement
    unit_of_measurement: ""
    accuracy_decimals: 2
    state_class: "measurement"

  - platform: template
    name: "${friendly_name} Sortie Triac"
    id: afstriac
    unit_of_measurement: "%"
    state_class: "measurement"  
    accuracy_decimals: 2

# Les MQTT sont déclarés dans le Node Red du Cerbo GX
# https://venus.local:1881/#flow/dbd727f16cbe7b5f

  - platform: mqtt_subscribe
    name: "${friendly_name} Pu batterie"
    id: pu_batteries
    topic: mp2/batteries/puissance
    unit_of_measurement: "W"
    state_class: "measurement"  
    accuracy_decimals: 2
    on_value:
      then:
        - lambda: id(pureseau1).publish_state( id(pureseau).state );
        - lambda: id(calcul_injection_mode_hp).execute();  
#        - lambda: id(pid).execute();  
        
  - platform: mqtt_subscribe
    name: "${friendly_name} Pu Mppt1"
    id: pu_mppt1
    topic: mp2/mppt1/puissance
    unit_of_measurement: "W"
    state_class: "measurement"  
    accuracy_decimals: 2

  - platform: mqtt_subscribe
    name: "${friendly_name} Pu Produite"
    id: pu_prod
    topic: mp2/multiplus2/prod_totale
    unit_of_measurement: "W"
    state_class: "measurement"  
    accuracy_decimals: 2
    on_value:
      then:
        if:
          condition:
            lambda: 'return id(pu_prod).state > id(seuil_prod).state;'
        # Si Production > au seuil alors OK
          then:
            - binary_sensor.template.publish:
                id: seuil_prod_ok
                state: ON
        # Sin
          else:
            - binary_sensor.template.publish:
                id: seuil_prod_ok
                state: OFF
            
  - platform: mqtt_subscribe
    name: "${friendly_name} Etat Bus VE"
    id: etatbus_ve
    topic: mp2/multiplus2/etatbusve
    accuracy_decimals: 0
# lecture sensor Home Assistant
  - platform: homeassistant
    name: "${friendly_name} Status Bus VE"
    entity_id: sensor.mp2_status_bus_ve
    id: statusbusve

  - platform: homeassistant
    name: "${friendly_name} Tarif Num"
    entity_id: sensor.linky_n_tarif
    id: hc

# Sonde Temperature radiateur
  - platform: dallas
    address: 0xeb012112e461b128
    name: "${friendly_name} Temp triac"
    id: temp_triac
    filters:
      - filter_out: NAN
    on_value:
      then:
        if:
          condition:
            lambda: 'return id(temp_triac).state < id(tmax).state;'
        # Si Temp Triac inferieur au seuil alors OK
          then:
            - binary_sensor.template.publish:
                id: temperatureok
                state: ON
        # Sinon attendre 60s avant retour à la normal
          else:
            - binary_sensor.template.publish:
                id: temperatureok
                state: OFF
            - delay: 60s

text_sensor:
  - platform: template
    name: "${friendly_name} Mode Regulation"
    id: moderegul

switch:
  - platform: gpio
    name: "${friendly_name} Relais"
    pin: GPIO5
    id: relais

  - platform: template
    name: "${friendly_name} Mode Auto"    
    id: modeauto
    optimistic: true
    restore_mode: always_on
    on_turn_off:
      - light.turn_off: gradateur

  - platform: restart
    name: "${friendly_name} Restart"

output:
#LEDS --------------------------------------
  - id: led_jaune
    platform: gpio
    pin: GPIO32
    
  - id: led_rouge
    platform: gpio
    pin: GPIO25
# Pilotage du Dimmer ------------------------
  - platform: ac_dimmer
    id: ecs
    gate_pin: GPIO33
    method: leading
    zero_cross_pin:
      number: GPIO34 
      mode:
        input: true
      inverted: yes
    min_power: 5%

light:
  - platform: monochromatic
    name: "${friendly_name} STriac"
    output: ecs
    id: gradateur
    default_transition_length: 50ms

# Affichage
display:
  - platform: lcd_pcf8574
    dimensions: 20x4
    address: 0x27
    update_interval: 2s
    lambda: |-
      it.printf(0,0,"Pr=%0.0fW",id(pureseau1).state);
      it.printf(10,0,"Pe=%0.0fW ",id(puecs).state);
      it.printf(0,1,"Tr=%0.1f%%",id(striac));
      it.printf(10,1,"Val:%s", id(val_routeur).state ? "OK" : "NOK");
      it.printf(0,2,"Tp=%0.1fc", id(temp_triac).state);
      it.printf(10,2,"Etat=%s", id(temperatureok).state ? "OK" : "NOK");
      it.printf(0,3,"Mode=%s", id(modeauto).state ? "Auto" : "Manu");
      it.printf(10,3,"Inc=%0.1f ",id(increment));    

interval:
  - interval: 2s
    then:
      - script.execute: etat_production 

#  - interval: 500ms
#    then:
#      - script.execute: pid
# ------------------------  Scripts
script:
# 
# Calcul PID
# https://www.ferdinandpiette.com/blog/2011/08/implementer-un-pid-sans-faire-de-calculs/
#    erreur = consigne - mesure;
#    somme_erreurs += erreur;
#    variation_erreur = erreur - erreur_précédente;
#    commande = Kp * erreur + Ki * somme_erreurs + Kd * variation_erreur;
#    erreur_précédente = erreur
  - id: pid
    mode: single
    then:
      - lambda: |-
          static float erreur;
          static float somme_erreurs;
          static float variation_erreur;
          static float erreur_precedente;
          static float sortie;
          somme_erreurs = 0.0;

          if (id(statusbusve).state == 3){
            id(cons_pid).publish_state(id(cons_pubatt).state);
            erreur = id(pu_batteries).state-id(cons_pid).state;
            id(moderegul).publish_state( "Sur Pu batteries Bulk PID");
          } else {
            if (id(pu_batteries).state >= id(seuil_pubatt).state){
              id(cons_pid).publish_state(0);
              erreur = id(pureseau).state-id(cons_pid).state;
              id(moderegul).publish_state( "Sur Pu reseau PID");
            } else { 
              id(cons_pid).publish_state(id(cons_pubatt).state);
              erreur = id(pu_batteries).state-id(cons_pid).state;
              id(moderegul).publish_state( "Sur Pu batteries Non Bulk PID");
            } 
          }  

          somme_erreurs += erreur;
          variation_erreur=erreur-erreur_precedente;
          sortie = (id(kp).state*erreur)+(id(ki).state*somme_erreurs)+(id(kd).state*variation_erreur);
          erreur_precedente= erreur;
          if (sortie <= 0){
            sortie = 0;
          } else if (sortie>=id(pmax).state){
            sortie = id(pmax).state;
          }

          id(striac) = sortie; 

          ESP_LOGI("Log","Erreurs: %f", erreur);
          ESP_LOGI("Log","SomErr: %f", somme_erreurs);
          ESP_LOGI("Log","VarPre: %f", variation_erreur);          
          ESP_LOGI("Log","ErrPre: %f", erreur_precedente);
          ESP_LOGI("Log","Sortie: %f",sortie);    
          ESP_LOGI("Log","Seuil: %c",seuil_prod_ok); 

      # Si Prod > seuil et mode auto et temp OK alors on active le triac et Sortie Triac superieur au mini
      - if: 
          condition:
            and:
              - binary_sensor.is_on: val_routeur
              - switch.is_on: modeauto
              - binary_sensor.is_on: seuil_prod_ok
              - binary_sensor.is_on: temperatureok

          then:
#""              - light.turn_on:
#                  id: gradateur
#                  brightness: !lambda |-
#                    return id(striac)/100 ;
              - output.set_level:
                  id: ecs                   
                  level: !lambda |-
                    return id(striac)/100 ;
              - logger.log:
                  format: "Log2 S Triac %f - Increment %f"
                  args: [ 'id(striac)', 'id(increment)' ]
                  level: "info"                   

      # Si mode routeur devalidé ou temp NOK alors on désactive le triac 
      - if: 
          condition:
            and:
              - switch.is_on: modeauto
              - or:
                - binary_sensor.is_off: val_routeur
                - binary_sensor.is_off: temperatureok   
                - binary_sensor.is_off: seuil_prod_ok                                 
          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            #- light.turn_off: gradateur
            - output.turn_off: ecs


      # Si mode routeur manu
      - if: 
          condition:
            and:
              - switch.is_off: modeauto
          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            - logger.log:
                format: "Log Manu STriac %f - Increment %f"
                args: [ 'id(striac)', 'id(increment)' ]
                level: "info"   

      - lambda: |-
            id(afstriac).publish_state( id(striac) );
      - logger.log:
          format: "Log3 S Triac %f - Increment %f"
          args: [ 'id(striac)', 'id(increment)' ]
          level: "info"


# Calcul puissance injection mode HP
  - id: calcul_injection_mode_hp
    mode: single
    then:
      # Si Bus Ve en Bulk on regule autour d'une consigne de puissance de charge Batteries de maniere à laisser de la puissance à router vers l'ECS
      #   Sinon
      # Si on regule autour du zero grid et d'un seuil puissance batteries
      # 
      # La régule consiste à incrementer ou decrementer la sortie triac 
      - lambda: |-
          if (id(statusbusve).state == 3){
            id(increment) = (id(pu_batteries).state-id(cons_pubatt).state)*id(coeff_rbat).state/1000;
            id(moderegul).publish_state( "Sur Pu batteries Bulk");
          } else {
            if (id(pu_batteries).state >= id(seuil_pubatt).state){
              id(increment) = id(pureseau1).state*id(coeff_r).state/1000*-1;
              id(moderegul).publish_state( "Sur Pu reseau");
            } else { 
              id(increment) = id(pu_batteries).state*id(coeff_rbat).state/1000;
              id(moderegul).publish_state( "Sur Pu batteries Non Bulk");
            } 
          }  
          
          id(striac) = id(striac)+id(increment);

          if (id(striac) <= 0){
            id(striac) = 0;
          } else if(id(striac)>=id(pmax).state){
            id(striac) = id(pmax).state;
          }        
      - logger.log:
          format: "Log S Triac %f - Increment %f"
          args: [ 'id(striac)', 'id(increment)' ]
          level: "info"

      
      # Si Prod > seuil et mode auto et temp OK alors on active le triac et Sortie Triac superieur au mini
      - if: 
          condition:
            and:
              - binary_sensor.is_on: val_routeur
              - switch.is_on: modeauto
              - binary_sensor.is_on: seuil_prod_ok
              - binary_sensor.is_on: temperatureok

          then:
              - light.turn_on:
                  id: gradateur
                  brightness: !lambda |-
                    return id(striac)/100 ;
              - logger.log:
                  format: "Log Auto OK STriac %f - Increment %f"
                  args: [ 'id(striac)', 'id(increment)' ]
                  level: "info"         

      # Si mode routeur devalidé ou temp NOK alors on désactive le triac 
      - if: 
          condition:
            and:
              - switch.is_on: modeauto
              - or:
                - binary_sensor.is_off: val_routeur
                - binary_sensor.is_off: temperatureok                    
                - binary_sensor.is_off: seuil_prod_ok
          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            - light.turn_off: gradateur
            - logger.log:
                format: "Log Auto NOk STriac %f - Increment %f"
                args: [ 'id(striac)', 'id(increment)' ]
                level: "info"                         


      # Si mode routeur manu
      - if: 
          condition:
            and:
              - switch.is_off: modeauto
          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            - logger.log:
                format: "Log Manu STriac %f - Increment %f"
                args: [ 'id(striac)', 'id(increment)' ]
                level: "info"                         
# Affichage STriac et Increment
      - lambda: |-
            id(afstriac).publish_state( id(striac) );
            id(afincrement).publish_state( id(increment) );

      - logger.log:
          format: "Log Fin STriac %f - Increment %f"
          args: [ 'id(striac)', 'id(increment)' ]
          level: "info"


# Injection en mode HC
  - id: calcul_injection_mode_hc
    mode: single
    then:
      # En HC on régule autour de la consigne pu Heure creuse
      # Le but est de ne pas trop solliciter le reseau
      # La régule consiste à incrementer ou decrementer la sortie triac 
      - lambda: |-
          id(increment) = (id(cons_puhc).state-id(pureseau1).state)*id(coeff_r).state/1000;
          id(moderegul).publish_state( "Sur Pu Heure Creuse");
       
      - lambda: |-
         id(striac) = id(striac)+id(increment);            

      - logger.log:
          format: "Log S Triac= %f"
          args: [ 'id(striac)']

      - lambda: |-
          if (id(striac) <= 0){
            id(striac) = 0;
          } else if(id(striac)>=id(pmax).state){
            id(striac) = id(pmax).state;
          }

      # Si mode routeur validé et mode auto et temp OK alors on active le triac et Sortie Triac superieur au mini
      - if: 
          condition:
            and:
              - switch.is_on: modeauto
              - binary_sensor.is_on: temperatureok
              - lambda: 'return id(striac) >= id(pmin).state;'
          then:
              - light.turn_on:
                  id: gradateur
                  brightness: !lambda |-
                    return id(striac)/100 ;


      # Si mode routeur devalidé ou temp NOK alors on désactive le triac 
      - if: 
          condition:
            and:
              - switch.is_on: modeauto
              - or:
                - binary_sensor.is_off: val_routeur
                - binary_sensor.is_off: temperatureok                    

          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(striac) ;  


# ------------  Pilotage led
  - id: etat_production
    mode: single
    then:
      - if: 
          condition:
            sensor.in_range:
              id: pureseau1
              below: -50
          then:
            - output.turn_on: led_rouge
          else:
            - output.turn_off: led_rouge
            
      - if: 
          condition:
            binary_sensor.is_on: val_routeur
          then:
            - output.turn_on: led_jaune
          else:
            - output.turn_off: led_jaune

