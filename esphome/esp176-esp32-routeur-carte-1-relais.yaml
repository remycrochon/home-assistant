substitutions:
  device_name: "esp176-esp32-routeur-1r"
  friendly_name: esp176
  adress_ip: "192.168.0.176"
  time_timezone: "Europe/Paris"
  
esphome:
  name: ${device_name}
  platform: ESP32
  board: esp32dev
  project:
    name: "rem81.esp176-esp32-routeur"
    version: "1.0.0"
  on_boot:
    priority: 800
    # Force mode auto et tempok au demmarrage
    then: 
      - switch.turn_on: modeauto
      - binary_sensor.template.publish:
          id: tempok
          state: ON

wifi:
  networks:
    - ssid: !secret wifi
      password: !secret mdpwifi
  reboot_timeout: 5min

  manual_ip:
    static_ip: ${adress_ip}
    gateway: 192.168.0.254
    subnet: 255.255.255.0

# Enable logging
logger:
  baud_rate: 0
  level: DEBUG
#  logs:
#    modbus.component: INFO
# Enable Home Assistant API
api:

ota:

web_server:
  port: 80

# Protocole afficheur
i2c:
  sda: GPIO21 
  scl: GPIO22
  scan: True
  id: bus_a

# Protocole du JSK
uart:
  id: mod_bus
  tx_pin: 17
  rx_pin: 16
  baud_rate: 38400
  stop_bits: 1
#  debug:
#    direction: BOTH
#    dummy_receiver: false
#    after:
#      timeout: 150ms
#    sequence:
#      - lambda: |-
#          UARTDebug::log_string(direction, bytes);

modbus:
#flow_control_pin: 5
  #send_wait_time: 200ms
  id: modbus1

modbus_controller:
  - id: jsymk
    ## the Modbus device addr
    address: 0x1
    modbus_id: modbus1
    update_interval: 0.75s
    command_throttle: 50ms
    
    # setup_priority: -10

globals:
   - id: increment
     type: float
     restore_value: no
     initial_value: '0'
   - id: striac
     type: float
     restore_value: yes


   - id: palier0
     type: int
     restore_value: no
     initial_value: '0'
   - id: palier1
     type: int
     restore_value: no
     initial_value: '15'
   - id: palier2
     type: int
     restore_value: no
     initial_value: '50'
   - id: palier3
     type: int
     restore_value: no
     initial_value: '100'
   - id: palier4
     type: int
     restore_value: no
     initial_value: '200'
   - id: palier5
     type: int
     restore_value: no
     initial_value: '300'
   - id: palier6
     type: int
     restore_value: no
     initial_value: '600'
   - id: palier7
     type: int
     restore_value: no
     initial_value: '900'


# Sonde Temperature Dallas
dallas:
  - pin: GPIO27 #
    update_interval: 60s

# Informations supplementaires sur le WIFI
#text_sensor:
#  - platform: wifi_info
#    ip_address:
#      name: ${friendly_name}_ESP IP Address
#    ssid:
#      name: ${friendly_name}_ESP Connected SSID
#    bssid:
#      name: ${friendly_name}_ESP Connected BSSID
#    mac_address:
#      name: ${friendly_name}_ESP Mac Wifi Address
#    scan_results:
#      name: ${friendly_name}_ESP Latest Scan Results


binary_sensor:
#Etat de la connection
  - platform: status
    name: "${friendly_name}_Status"

  - platform: template
    name: "${friendly_name} Temp Ok"
    id: tempok

# Input Number
number:
  # Seuil Min/Max sortie triac
  - platform: template
    name: "${friendly_name} P Max"
    id: pmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 50
    max_value: 100
    unit_of_measurement: "%"
    step: 1

  - platform: template
    name: "${friendly_name} P Min"
    id: pmin
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 25
    unit_of_measurement: "%"
    step: 1

# Seuil MAX temperature
  - platform: template
    name: "${friendly_name} T Max"
    id: tmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 75
    unit_of_measurement: "C°"
    step: 1

# Coeff Réactivité
  - platform: template
    name: "${friendly_name} Coeff R"
    id: coeff_r
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 1000
    unit_of_measurement: ""
    step: 1


sensor:  

# tension de l'alimentation
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: Tension
    #name: "${friendly_name} Tension JSYMK"
    address: 0x0048
    unit_of_measurement: "V"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Intensité traversant le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: Itore
    name: "${friendly_name} I_ECS JSYMK"
    address: 0x0049
    unit_of_measurement: "A"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Puissance traversant le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: puecs
    name: "${friendly_name} P_ECS JSYMK"
    address: 0x004A
    unit_of_measurement: "W"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Energie lue dans le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: energietore
    name: "${friendly_name} Energie ECS JSYMK"
    address: 0x004B
    unit_of_measurement: "kWh"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Energie lue dans le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: fptore
    #name: "${friendly_name} FP Tore JSYMK"
    address: 0x004C
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Energie NEG lue dans le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: energietoren
    name: "${friendly_name} Energie ECS Neg JSYMK"
    address: 0x004D
    unit_of_measurement: "kWh"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001     
    register_count: 1
    response_size: 4 
# Sens du courant dans la pince
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: senspince
    #name: "${friendly_name} Sens_Pince JSYMK"
    address: 0x004E
    register_type: holding
    value_type: U_DWORD
    bitmask: 0X00010000
    filters:
      - multiply: 1
    register_count: 1
    response_size: 4
# Sens du courant dans le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: senstor
    #name: "${friendly_name} Sens_Tore JSYMK"
    address: 0x004E
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 0
    bitmask: 0X01000000
    filters:
      - multiply: 1
    register_count: 1
    response_size: 4

# Fréquence de l'alimentation  
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: frequence
    #name: "${friendly_name} Frequence JSYMK"
    address: 0x004F
    unit_of_measurement: "hz"    
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.01
    register_count: 1
    response_size: 4

# tension de l'alimentation
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: Tension2
    #name: "${friendly_name} U_Reseau JSYMK"
    address: 0x0050
    unit_of_measurement: "V"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4
    
# Intensité lue dans la pince
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: Ireseau
    #name: "${friendly_name} I_Reseau JSYMK"
    address: 0x0051
    unit_of_measurement: "A"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# puissance lue dans la pince
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: pureseau
    #name: "${friendly_name} P_Reseau JSYMK"
    address: 0x0052
    unit_of_measurement: "W"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4 
    on_value:
      then:
        - lambda: |-
            if ( id(senspince).state == 1 ) {
              id(pureseau1).publish_state( id(pureseau).state *-1);
            } else {
              id(pureseau1).publish_state( id(pureseau).state );
            }
        - lambda: id(afincrement).publish_state( id(increment) );
        - script.execute: calcul_injectionv2
        - script.execute: etat_production 
        - lambda: id(afstriac).publish_state( id(striac) );
    
# Energie lue dans la pince
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: energiepince
    #name: "${friendly_name} Energie Reseau JSYMK"
    address: 0x0053
    unit_of_measurement: "kWh"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Energie lue dans le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: fppince
    #name: "${friendly_name} FP Pince JSYMK"
    address: 0x0054
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001
    register_count: 1
    response_size: 4

# Energie NEG lue dans le tore
  - platform: modbus_controller
    modbus_controller_id: jsymk
    id: energienegpince
    #name: "${friendly_name} Energie ECS Neg JSYMK"
    address: 0x0055
    unit_of_measurement: "kWh"
    register_type: holding
    value_type: U_DWORD
    accuracy_decimals: 1
    filters:
      - multiply: 0.0001     
    register_count: 1
    response_size: 4 
    
# Informations WI_FI
  - platform: wifi_signal # Affiche le signal WiFi strength/RSSI en dB
    name: "${friendly_name} WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: copy # Affiche le signal WiFi strength en %
    source_id: wifi_signal_db
    name: "${friendly_name} WiFi Signal Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"

############### TEMPLATE  ######################"
# Affichage dans HA et sur l'afficheur
  - platform: template
    name: "${friendly_name} Pu Reseau"
    id: pureseau1
    unit_of_measurement: "W"
    state_class: "measurement"  
 
  - platform: template
    name: "${friendly_name} Increment"
    id: afincrement
    unit_of_measurement: ""
    accuracy_decimals: 2
    state_class: "measurement"

  - platform: template
    name: "${friendly_name} Sortie Triac"
    id: afstriac
    unit_of_measurement: "%"
    state_class: "measurement"  
    accuracy_decimals: 2

# Sonde Temperature radiateur
  - platform: dallas
    address: 0xeb012112e461b128
    name: "${friendly_name} Temp triac"
    id: temp_triac
    filters:
      - filter_out: NAN
    on_value:
      then:
        if:
          condition:
            lambda: 'return id(temp_triac).state < id(tmax).state;'
        # Si Temp Triac inferieur au seuil alors OK
          then:
            - binary_sensor.template.publish:
                id: tempok
                state: ON
        # Sinon attendre 60s avant retour à la normal
          else:
            - binary_sensor.template.publish:
                id: tempok
                state: OFF
            - delay: 60s
 
switch:
  - platform: gpio
    name: "${friendly_name} Relais"
    pin: GPIO5
    id: relais

  - platform: template
    name: "${friendly_name} Validation Router"    
    id: val_router
    optimistic: true
    restore_state: true   

  - platform: template
    name: "${friendly_name} Mode Auto"    
    id: modeauto
    optimistic: true
    restore_state: false  

  - platform: restart
    name: "${friendly_name} Restart"

output:
#LEDS --------------------------------------
  - id: led_conso
    platform: gpio
    pin: GPIO32
    
  - id: led_injec
    platform: gpio
    pin: GPIO25
# Pilotage du Dimmer ------------------------
  - platform: ac_dimmer
    id: ecs
    gate_pin: GPIO33
    method: leading
    zero_cross_pin:
      number: GPIO34 
      mode:
        input: true
      inverted: yes
    min_power: 5%

light:
  - platform: monochromatic
    name: "${friendly_name}+STriac"
    output: ecs
    id: gradateur
    default_transition_length: 50ms

# Affichage
display:
  - platform: lcd_pcf8574
    dimensions: 20x4
    address: 0x27
    update_interval: 2s
    lambda: |-
      it.printf(0,0,"Pr=%0.0fW",id(pureseau1).state);
      it.printf(10,0,"Pe=%0.0fW ",id(puecs).state);
      it.printf(0,1,"Tr=%0.1f%%",id(striac));
      it.printf(10,1,"Val:%s", id(val_router).state ? "OK" : "NOK");
      it.printf(0,2,"Tp=%0.1fc", id(temp_triac).state);
      it.printf(10,2,"Etat=%s", id(tempok).state ? "OK" : "NOK");
      it.printf(0,3,"Mode=%s", id(modeauto).state ? "Auto" : "Manu");
      it.printf(10,3,"Inc=%0.1f ",id(increment));     
#interval:

#  - interval: 0.5s
#    then:

     #  - script.execute: 

# ------------------------  Scripts
script:
# 
# ------------------------ Calcul puissance injection V2
  - id: calcul_injectionv2
    mode: single
    then:
      - lambda: |-
         id(increment) = id(pureseau1).state*id(coeff_r).state/1000*-1;
 
      - lambda: |-
         id(striac) = id(striac)+id(increment);            

      - logger.log:
          format: "Log S Triac= %f"
          args: [ 'id(striac)']

      - lambda: |-
          if (id(striac) <= 0){
            id(striac) = 0;
          } else if(id(striac)>=id(pmax).state){
            id(striac) = id(pmax).state;
          }

      # Si mode routeur validé et mode auto et temp OK alors on active le triac et Sortie Triac superieur au mini
      - if: 
          condition:
            and:
              - switch.is_on: val_router
              - switch.is_on: modeauto
              - binary_sensor.is_on: tempok
              - lambda: 'return id(striac) >= id(pmin).state;'
          then:
              - light.turn_on:
                  id: gradateur
                  brightness: !lambda |-
                    return id(striac)/100 ;
      # Si mode routeur devalidé ou temp NOK alors on désactive le triac 
      - if: 
          condition:
              or:
                - switch.is_off: val_router
                - binary_sensor.is_off: tempok                    
          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(0) ;  

#
#----------------------------------- Calcul puissance injection V1
  - id: calcul_injectionv1
    mode: single
    then:
      - lambda: |-
         id(increment) = 0.0;
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier0) && abs(id(pureseau1).state) < id(palier1);
          then:
            - lambda: |-
                id(increment) = 0.0;
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier1) && abs(id(pureseau1).state) < id(palier2);
          then:
            - lambda: |-
               id(increment) = 0.5;
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier2) && abs(id(pureseau1).state) < id(palier3);
          then:
            - lambda: |-
               id(increment) = 1.0;               
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier3) && abs(id(pureseau1).state) < id(palier4);
          then:
            - lambda: |-
               id(increment) = 1.5;               
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier4) && abs(id(pureseau1).state) < id(palier5);
          then:
            - lambda: |-
               id(increment) = 2.0;
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier5) && abs(id(pureseau1).state) < id(palier6);
          then:
            - lambda: |-
               id(increment) = 2.5;
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier6) && abs(id(pureseau1).state) < id(palier7);
          then:
            - lambda: |-
               id(increment) = 3.0;                                       
      - if: 
          condition:
            lambda: |-
              return abs(id(pureseau1).state) >= id(palier7);
          then:
            - lambda: |-
               id(increment) = 4.0;

      - if: 
          condition:
            lambda: |-
              return id(pureseau1).state < 0;
          then:
            - lambda: |-
                id(striac) = id(striac)+id(increment);
          else:
            - lambda: |-
                id(striac) = id(striac)-id(increment);            

      - logger.log:
          format: "Log S Triac= %f"
          args: [ 'id(striac)']

      - lambda: |-
          if (id(striac) <= 0){
            id(striac) = 0;
          } else if(id(striac)>=id(pmax).state){
            id(striac) = id(pmax).state;
          }

      # Si mode routeur validé et mode auto et temp OK alors on active le triac et Sortie Triac superieur au mini
      - if: 
          condition:
            and:
              - switch.is_on: val_router
              - switch.is_on: modeauto
              - binary_sensor.is_on: tempok
              - lambda: 'return id(striac) >= id(pmin).state;'
          then:
              - light.turn_on:
                  id: gradateur
                  brightness: !lambda |-
                    return id(striac)/100 ;
      # Si mode routeur devalidé ou temp NOK alors on désactive le triac 
      - if: 
          condition:
              or:
                - switch.is_off: val_router
                - binary_sensor.is_off: tempok                    
          then:
            - lambda: |-
                id(striac) = 0;
                id(increment) = 0;
            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(0) ;  

# -------------------------------------------  Pilotage led
  - id: etat_production
    mode: single
    then:
     - if: 
         condition:
           sensor.in_range:
              id: pureseau1
              below: 50
              above: -50
         then:
           - output.turn_on: led_conso
           - output.turn_on: led_injec
                
     - if: 
         condition:
           sensor.in_range:
             id: pureseau1
             above: 50
         then:
           - output.turn_off: led_injec
           - output.turn_on: led_conso

     - if: 
         condition:
           sensor.in_range:
             id: pureseau1
             below: -50
         then:
          - output.turn_off: led_conso
          - output.turn_on: led_injec

