substitutions:
  device_name: "esp176-routeur"
  friendly_name: esp176
  adress_ip: "192.168.0.176"
  time_timezone: "Europe/Paris"
  # Affectation des GPIO
  GPIO_onewire: "GPIO27"
  GPIO_sda: "GPIO21"
  GPIO_scl: "GPIO22"
  GPIO_tx: "GPIO17"
  GPIO_rx: "GPIO16"  
  GPIO_Led_jaune: "GPIO26"
  GPIO_Led_rouge: "GPIO25"
  GPIO_Led_status: "GPIO32"
  GPIO_Relais: "GPIO5"
  # Dimmer
  GPIO_Gate_pin: "GPIO33"
  GPIO_ZC_pin: "GPIO34"

packages:
  jsk: !include pack_esp176/jsk.yaml
  table_pu: !include pack_esp176/table_pu.yaml

esphome:
  name: ${device_name}
  on_boot:
    priority: -100
    # Force mode auto et tempok au demarrage
    then: 
      - binary_sensor.template.publish:
          id: temperatureok
          state: ON

esp32:
  board: esp32dev
  framework:
    type: arduino
    
wifi:
  networks:
    - ssid: !secret wifi_esp
      password: !secret mdpwifi_esp
  reboot_timeout: 5min

  manual_ip:
    static_ip: ${adress_ip}
    gateway: 192.168.0.254
    subnet: 255.255.255.0
    dns1: !secret dns1
    dns2: !secret dns2
    
    
# Utilisez la LED bleue de l'appareil comme LED d'Ã©tat, qui clignotera s'il y a des avertissements (lent) ou des erreurs (rapide)
status_led:
  pin:
    number: ${GPIO_Led_status} # led jaune
    inverted: true

# Enable logging
logger:
  baud_rate: 0
  level: info

#    modbus.component: INFO
# Enable Home Assistant API
api:

ota:
  platform: esphome
web_server:
  port: 80
  version: 3

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Paris
    servers:
     - 0.pool.ntp.org
     - 1.pool.ntp.org
     - 2.pool.ntp.org  

# Protocole I2C
i2c:
  sda: ${GPIO_sda}
  scl: ${GPIO_scl}
  scan: True
  id: bus_a
  frequency: 400kHz

# Mosquitto HA
mqtt:
  broker: 192.168.0.37
  username: !secret mqtt_ha_name
  password: !secret mqtt_ha_pw
  discovery: false  
  birth_message:            # dÃ©sactive les messages de dÃ©marrage
  will_message:             # dÃ©sactive les messages "offline"
  log_topic: null           # dÃ©sactive les logs MQTT
  topic_prefix: "esp176mute"  # Ã©vite toute collision avec HA
  
globals:
  - id: p_dispo
    type: float
    restore_value: no
    initial_value: '0'
  - id: regul
    type: std::string
    restore_value: no
    initial_value: '"Pas de rÃ©gulation"'
  - id: striac
    type: float
    restore_value: no
    initial_value: '0'

  # stocke temporairement le message Ã  envoyer Ã  telegram
  - id: telegram_msg_buffer
    type: std::string
    restore_value: no
    initial_value: '""'

#Â Sonde Temperature Dallas
one_wire:
  - platform: gpio  
    pin: ${GPIO_onewire}

# dÃ©claration des modes de fonctionnement dans des "input select"
select:
  - platform: template
    name: "Mode_Fonctionnement_routeur"
    optimistic: true
    restore_value: true
    options:
      - Auto
      - Manu
      - Arret
      - Etalonnage
    id: _Mode_Fonctionnement_routeur
    on_value: 
      then:
        - lambda: |-
            char mess[128];
            snprintf(mess, sizeof(mess), "Mode Fonctionnement Routeur: %s", id(_Mode_Fonctionnement_routeur).state.c_str());
            ESP_LOGI("fichier", "Message: %s", mess);
            id(_log_fichier).execute(mess);  // Appelle le script _log_fichier avec le paramÃ¨tre mess      
        # Passage en mode Ã©talonnage
        - if:
            condition:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Etalonnage";'
            then:
              - script.execute: etalonnage_striac
        # Passage en mode Manu on remet Ã  Zero le valid Routeur et la consigne Manu
        - if:
            condition:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Manu";'
            then:
              - lambda: |-
                  id(ctriac_manu).publish_state(0);
              - switch.turn_off: validrouteur
        # Passage dans tous les modes on met Ã  zÃ©ro le triac
        - lambda: |-
            id(striac) = 0;
        - light.turn_off:
            id: gradateur
        - script.execute: calcul_injection_hp     

binary_sensor:
  #Etat de la connection
    - platform: status
      name: "Status"
  
    - platform: template
      name: "Temp Ok"
      id: temperatureok
  
    - platform: template
      name: "Seuil Prod Ok"
      id: seuil_prod_ok

    - platform: template
      name: "Seuil SOC Ok"
      id: seuil_soc_ok
  
# Input Number
number:
  # seuil SOC validation routeur
  - platform: template
    name: "Consigne Triac en manu"
    id: ctriac_manu
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 100
    unit_of_measurement: "%"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # Max sortie triac
  - platform: template
    name: "Puissance Max Triac"
    id: pmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 10
    max_value: 3000
    unit_of_measurement: "W"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # Seuil MAX temperature
  - platform: template
    name: "T Max"
    id: tmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 75
    unit_of_measurement: "CÂ°"
    step: 0.1
    icon: mdi:arrow-collapse-vertical

  # Consigne RÃ©gul sur Puissance Batteries en mode Bulk
  - platform: template
    name: "Reserve Charge Batteries"
    id: res_pubatt
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 2500
    unit_of_measurement: "W"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # seuil SOC validation routeur
  - platform: template
    name: "Seuil SOC"
    id: seuil_soc
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 100
    unit_of_measurement: "%"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # seuil Production Photovoltaique de validation routeur 
  - platform: template
    name: "Seuil Production Val Routeur"
    id: seuil_prod
    optimistic: true
    restore_value: true
    mode: box
    min_value: 100
    max_value: 3000
    unit_of_measurement: "W"
    step: 1
    icon: mdi:arrow-collapse-vertical

  - platform: template
    name: "Seuil Bas ECS"
    id: seuil_bas_ha
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 60
    unit_of_measurement: "CÂ°"
    step: 1
    icon: mdi:arrow-collapse-vertical    

  - platform: template
    name: "Seuil Haut ECS"
    id: seuil_haut_ha
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 60
    unit_of_measurement: "CÂ°"
    step: 1
    icon: mdi:arrow-collapse-vertical    

sensor:
  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    device_class: ""
    
  ############### TEMPLATE  ######################"
  # Affichage dans HA et sur l'afficheur
  # Puissance lue par le JSk- NÃ©gative en injection/Positive en soutirage
  - platform: template
    name: "Pu Reseau"
    id: pureseau1
    unit_of_measurement: "W"
    state_class: "measurement"
    accuracy_decimals: 0
  # Sortie triac de 0Ã 100%
  - platform: template
    name: "Sortie Triac"
    id: afstriac
    unit_of_measurement: "%"
    state_class: "measurement"  
    accuracy_decimals: 2
  # Pu disponible
  - platform: template
    name: "Pu Disponible"
    id: afpdispo
    unit_of_measurement: "W"
    state_class: "measurement"
    accuracy_decimals: 0

  # Sensor Intermediaire pour synoptique
  - platform: template
    name: "Cons batt en Cours"
    id: cons_batt_cours
    state_class: "measurement"
    unit_of_measurement: "W"
    accuracy_decimals: 0

  # Les MQTT sont dÃ©clarÃ©s dans le Node Red du Cerbo GX
  # https://venus.local:1881/#flow/dbd727f16cbe7b5f

  - platform: mqtt_subscribe
    id: conso_maison
    topic: mp2/multiplus2/conso_out1
    unit_of_measurement: "W"
    state_class: "measurement"  
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: mqtt_subscribe
    id: pu_batteries
    topic: mp2/batteries/puissance
    unit_of_measurement: "W"
    state_class: "measurement"  
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
        
  - platform: mqtt_subscribe
    id: pu_prod
    topic: mp2/multiplus2/prod_totale
    unit_of_measurement: "W"
    state_class: "measurement"  
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: mqtt_subscribe
    id: soc
    topic: mp2/batteries/soc
    unit_of_measurement: "%"
    state_class: "measurement"  
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
          
  - platform: mqtt_subscribe
    id: etatbus_ve
    topic: mp2/multiplus2/etatbusve
    accuracy_decimals: 0

  # lecture sensor Home Assistant

  - platform: homeassistant
    entity_id: sensor.esp124_tic_linky_n_tarif
    id: tarif
    internal: true

  - platform: homeassistant
    entity_id: sensor.ecocompteur_clim
    id: pu_clim
    internal: true

  # Sonde Temperature radiateur
  - platform: dallas_temp
    address: 0xeb012112e461b128
    name: "Temp triac"
    id: temp_triac
    update_interval: 60s
    filters:
      - filter_out: NAN

  # TempÃ©rature ECS et seuils HA
  - platform: homeassistant
    id: temp_ecs_ha
    entity_id: sensor.esp126_temp_ecs
    name: "TempÃ©rature ECS HA"


# dÃ©claration des "text_sensors"
text_sensor:
  - platform: template
    name: "Mode Regulation"
    id: moderegul

switch:
  - platform: gpio
    name: "Relais"
    pin: ${GPIO_Relais}
    id: relais

  - platform: template
    name: "Valid Routeur"    
    id: validrouteur
    optimistic: true
    restore_mode: always_on

  - platform: restart
    name: "Restart"

output:
  #LEDS --------------------------------------
  - id: led_jaune
    platform: gpio
    pin: ${GPIO_Led_jaune} 

  - id: led_rouge
    platform: gpio
    pin: ${GPIO_Led_rouge}

  # Pilotage du Dimmer
  - platform: ac_dimmer
    id: ecs
    gate_pin: ${GPIO_Gate_pin}
    method: leading
    zero_cross_pin:
      number: ${GPIO_ZC_pin} 
      mode:
        input: true
      inverted: yes
    min_power: 5%

light:
  - platform: monochromatic
    name: "STriac"
    output: ecs
    id: gradateur
    default_transition_length: 50ms

  # Affichage
display:
  - platform: lcd_pcf8574
    dimensions: 20x4
    address: 0x27
    update_interval: 20s  # Plus espacÃ© pour allÃ©ger la charge CPU
    lambda: |-
      char ligne0[21];
      char ligne1[21];
      char ligne2[21];
      char ligne3[21];

      snprintf(ligne0, sizeof(ligne0), "Pr=%0.0fW Pe=%0.0fW", id(pureseau1).state, id(puecs).state);
      snprintf(ligne1, sizeof(ligne1), "Tr=%0.1f%% V:%s", id(striac), id(validrouteur).state ? "OK" : "NOK");
      snprintf(ligne2, sizeof(ligne2), "Tp=%0.1fc E:%s", id(temp_triac), id(temperatureok).state ? "OK" : "NOK");
      snprintf(ligne3, sizeof(ligne3), "Mode:%s", id(_Mode_Fonctionnement_routeur).state.c_str());

      it.print(0, 0, ligne0);
      it.print(0, 1, ligne1);
      it.print(0, 2, ligne2);
      it.print(0, 3, ligne3);

interval:
  - interval: 1s
    then:
    - if:
        condition:
          lambda: |-
            return (id(tarif).state == 2 ||id(tarif).state == 4 ||id(tarif).state == 6) ; // Tarif HP(2/4/6) 
            //return (id(tarif).state == 1 ||id(tarif).state == 3 ||id(tarif).state == 5) ; // tarif HC (1/3/5)
        then:
          - script.execute: calcul_injection_hp
        else:
          # - script.execute: calcul_injection_hp
          - script.execute: calcul_injection_hc 

  - interval: 5s
    then:      
      - script.execute: etat_production
      - script.execute: calcul_relais_surprod      

 ########################################################################""
script:
  ########################################################################
  # ðŸ”¹ Script : calcul_injection_hp
  # -------------------------------------------------------
  # Fonction :
  #   - Pilotage du triac ECS en mode "Auto" pendant les heures pleines (HP)
  #   - Active la rÃ©gulation par interpolation si toutes les conditions sont OK
  #   - GÃ¨re aussi les modes "Manu" et "Arret"
  #
  # Conditions requises pour activer la rÃ©gulation :
  #   âœ… Mode Auto actif
  #   âœ… Routeur validÃ©
  #   âœ… Production PV > seuil dÃ©fini
  #   âœ… SOC batterie > seuil SOC
  #   âœ… TempÃ©rature triac infÃ©rieure Ã  T_max
  #
  # Cas gÃ©rÃ©s :
  #   1ï¸âƒ£ Arret ou conditions NOK â†’ triac = 0
  #   2ï¸âƒ£ Auto + conditions OK â†’ appel du script regulation_interpolation
  #   3ï¸âƒ£ Manu â†’ application directe de la consigne ctriac_manu
  #
  ########################################################################
  - id: calcul_injection_hp
    mode: single
    then:
      - lambda: |-
          // ============================================================
          // ðŸ§­ Ã‰VALUATION DES CONDITIONS DE DÃ‰MARRAGE
          // ============================================================

          // âœ… VÃ©rifie si la production solaire est suffisante
          bool prod_ok = (id(pu_prod).state > id(seuil_prod).state);
          id(seuil_prod_ok).publish_state(prod_ok);

          // âœ… VÃ©rifie si le SOC est supÃ©rieur au seuil (avec hysteresis de 2%)
          bool soc_ok = false;
          if (id(soc).state >= id(seuil_soc).state) {
            soc_ok = true;
          } else if (id(soc).state < (id(seuil_soc).state - 2)) {
            soc_ok = false;
          }
          id(seuil_soc_ok).publish_state(soc_ok);

          // âœ… VÃ©rifie la tempÃ©rature du radiateur triac
          bool temp_ok = (id(temp_triac).state < (id(tmax).state - 2));
          if (!temp_ok) {
            id(temperatureok).publish_state(false);
          } else {
            id(temperatureok).publish_state(true);
          }

          // ------------------------------------------------------------
          // ðŸª¶ Log synthÃ©tique pour supervision
          // ------------------------------------------------------------
          ESP_LOGI("HP", 
            "Check HP â†’ Prod=%.0fW (Seuil=%.0f) | SOC=%.1f%% (Seuil=%.1f) | TempTriac=%.1fÂ°C (Tmax=%.1fÂ°C)",
            id(pu_prod).state, id(seuil_prod).state,
            id(soc).state, id(seuil_soc).state,
            id(temp_triac).state, id(tmax).state
          );

      # ============================================================
      # 1ï¸âƒ£ Conditions NOK ou mode Arret â†’ arrÃªt complet
      # ============================================================
      - if:
          condition:
            or:
              # Cas 1 : Mode Arret
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Arret";'
              # Cas 2 : Mode Auto mais conditions NOK
              - and:
                  - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Auto";'
                  - or:
                      - switch.is_off: validrouteur
                      - binary_sensor.is_off: temperatureok
                      - binary_sensor.is_off: seuil_prod_ok
                      - binary_sensor.is_off: seuil_soc_ok
          then:
            - lambda: |-
                id(striac) = 0;
                id(moderegul).publish_state("OFF");
                id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);
                ESP_LOGW("HP", "âš ï¸ RÃ©gulation OFF : conditions NOK ou arrÃªt manuel.");
            - light.turn_off: gradateur

      # ============================================================
      # 2ï¸âƒ£ Mode Auto + toutes conditions OK â†’ rÃ©gulation active
      # ============================================================
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Auto";'
              - switch.is_on: validrouteur
              - binary_sensor.is_on: seuil_prod_ok
              - binary_sensor.is_on: temperatureok
              - binary_sensor.is_on: seuil_soc_ok
          then:
            - logger.log:
                format: "âœ… Conditions OK (HP) â†’ RÃ©gulation interpolation active"
                level: INFO
            - script.execute: regulation_interpolation

            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(striac) / 100.0f;

      # ============================================================
      # 3ï¸âƒ£ Mode Manuel â†’ application directe de la consigne
      # ============================================================
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Manu";'
              - switch.is_on: validrouteur
          then:
            - lambda: |-
                // Application directe de la consigne manuelle
                id(striac) = id(ctriac_manu).state;
                id(afpdispo).publish_state(0);
                id(moderegul).publish_state("Manu");
                id(cons_batt_cours).publish_state(0);
                ESP_LOGI("HP", "ðŸ§© Mode MANU â†’ Triac forcÃ© Ã  %.1f%%", id(striac));
            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(striac) / 100.0f;

      # ============================================================
      # ðŸ–¥ï¸ Publication de la valeur du triac (affichage + MQTT)
      # ============================================================
      - lambda: |-
          id(afstriac).publish_state(id(striac));
  ########################################################################
  # ðŸ”¹ Script : calcul_injection_hc (avec hystÃ©rÃ©sis ECS)
  # -------------------------------------------------------
  # Fonction :
  #   - Chauffe ECS uniquement pendant les heures creuses.
  #   - Utilise une table {Pu_reseau â†’ %Triac} pour moduler la chauffe.
  #   - VÃ©rifie les conditions de sÃ©curitÃ© et la tempÃ©rature ECS.
  #
  # Conditions dâ€™activation :
  #   âœ… Mode Auto actif
  #   âœ… Routeur validÃ©
  #   âœ… TempÃ©rature triac < T_max
  #   âœ… Pas dâ€™injection rÃ©seau nÃ©gative (< -10 W)
  #   âœ… ECS sous le seuil bas (temp_ecs < seuil_bas)
  #
  # Cas gÃ©rÃ©s :
  #   1ï¸âƒ£ Arret ou conditions NOK â†’ arrÃªt complet
  #   2ï¸âƒ£ Auto + OK â†’ rÃ©gulation via table
  #   3ï¸âƒ£ Manu â†’ triac = consigne manuelle
  #
  ########################################################################
  - id: calcul_injection_hc
    mode: single
    then:

      # ============================================================
      # ðŸ§­ Ã‰VALUATION DES CONDITIONS DE DÃ‰MARRAGE
      # ============================================================
      - lambda: |-
          float temp_ecs   = id(temp_ecs_ha).state;
          float seuil_bas  = id(seuil_bas_ha).state;
          float seuil_haut = id(seuil_haut_ha).state;
          float p_reseau   = id(pureseau1).state;

          // âœ… TempÃ©rature triac OK ?
          bool temp_ok = (id(temp_triac).state < (id(tmax).state - 2));
          id(temperatureok).publish_state(temp_ok);

          // âœ… VÃ©rifie si ECS en chauffe (zone hystÃ©rÃ©sis)
          bool ecs_froide = (temp_ecs < seuil_bas);
          bool ecs_chaude = (temp_ecs >= seuil_haut);
          bool ecs_hysteresis = id(moderegul).state == "HC Chauffe active";  // continue si dÃ©jÃ  ON

          // âœ… Injection rÃ©seau ?
          bool pas_injection = (p_reseau >= -10);

          // âœ… Log synthÃ©tique
          ESP_LOGI("HC",
            "Check HC â†’ ECS=%.1fÂ°C (%.1fâ€“%.1f) | P_RÃ©seau=%.0fW | TempTriac=%.1fÂ°C | Valid=%d | TempOK=%d",
            temp_ecs, seuil_bas, seuil_haut,
            p_reseau, id(temp_triac).state,
            id(validrouteur).state, temp_ok
          );

      # ============================================================
      # 1ï¸âƒ£ Conditions NOK ou mode Arret â†’ arrÃªt complet
      # ============================================================
      - if:
          condition:
            or:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Arret";'
              - and:
                  - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Auto";'
                  - or:
                      - switch.is_off: validrouteur
                      - binary_sensor.is_off: temperatureok
          then:
            - lambda: |-
                id(striac) = 0;
                id(moderegul).publish_state("HC OFF - Conditions NOK ou arrÃªt");
                id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);
                ESP_LOGW("HC", "âš ï¸ Chauffe OFF : conditions NOK ou arrÃªt manuel.");
            - light.turn_off: gradateur

      # ============================================================
      # 2ï¸âƒ£ Mode Auto + toutes conditions OK â†’ rÃ©gulation interpolation (HC)
      # ============================================================
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Auto";'
              - switch.is_on: validrouteur
              - binary_sensor.is_on: temperatureok
          then:
            - lambda: |-
                float temp_ecs   = id(temp_ecs_ha).state;
                float seuil_bas  = id(seuil_bas_ha).state;
                float seuil_haut = id(seuil_haut_ha).state;
                float p_reseau   = id(pureseau1).state;

                bool pas_injection  = (p_reseau >= -10);
                bool ecs_froide     = (temp_ecs <  seuil_bas);
                bool ecs_chaude     = (temp_ecs >= seuil_haut);
                bool chauffe_active = (id(moderegul).state == "HC Chauffe active");

                // ðŸš¨ SÃ©curitÃ© injection rÃ©seau
                if (!pas_injection) {
                  id(striac) = 0;
                  id(moderegul).publish_state("HC SÃ©curitÃ© Injection OFF");
                  ESP_LOGI("HC", "Injection rÃ©seau dÃ©tectÃ©e (%.0f W) â†’ OFF", p_reseau);
                }
                // ðŸ”¥ HystÃ©rÃ©sis ECS : on chauffe si ECS froide ou maintien si dÃ©jÃ  en chauffe
                else if (ecs_froide || chauffe_active) {
                  if (ecs_chaude) {
                    id(striac) = 0;
                    id(moderegul).publish_state("HC ECS OK - Chauffe OFF");
                    ESP_LOGI("HC", "ECS %.1fÂ°C â‰¥ %.1fÂ°C â†’ Chauffe arrÃªtÃ©e", temp_ecs, seuil_haut);
                  } else {
                    // ðŸ‘‰ DÃ‰LÃˆGUE LE CALCUL Ã€ regulation_interpolation (branche HC interne)
                    id(moderegul).publish_state("HC Chauffe active");
                    ESP_LOGI("HC", "ECS %.1fÂ°C < %.1fÂ°C â†’ Appel interpolation (HC)", temp_ecs, seuil_bas);
                    id(regulation_interpolation).execute();  // appelle le script par son id
                  }
                }
                // âš–ï¸ Zone neutre : pas de chauffe
                else {
                  id(striac) = 0;
                  id(moderegul).publish_state("HC Attente");
                  ESP_LOGI("HC", "ECS %.1fÂ°C dans plage neutre â†’ OFF", temp_ecs);
                }

            - light.turn_on:
                id: gradateur
                brightness: !lambda 'return id(striac) / 100.0f;'

            - lambda: |-
                id(afstriac).publish_state(id(striac));
                //id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);

      # ============================================================
      # 3ï¸âƒ£ Mode Manuel â†’ application directe de la consigne
      # ============================================================
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).state == "Manu";'
              - switch.is_on: validrouteur
          then:
            - delay: 500ms
            - lambda: |-
                id(striac) = id(ctriac_manu).state;
                id(moderegul).publish_state("HC Mode Manu");
                id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);
                ESP_LOGI("HC", "ðŸ§© Mode MANU â†’ Triac forcÃ© Ã  %.1f%%", id(striac));
            - light.turn_on:
                id: gradateur
                brightness: !lambda 'return id(striac) / 100.0f;'
            - lambda: |-
                id(afstriac).publish_state(id(striac));

   ########################################################################
  # ðŸ”¹ Script : regulation_interpolation (commun HP + HC)
  # -------------------------------------------------------
  # RÃ´le :
  #   - Calcule p_dispo puis striac par interpolation (table_puissance)
  #   - Deux branches internes :
  #       * HP â†’ logique PV/batterie (Bulk / Absorb / Float)
  #       * HC â†’ objectif de puissance rÃ©seau (ex. 6000 W) pour ECS
  #
  # HypothÃ¨se sur le capteur tarif :
  #   Ajuste ICI la condition is_hp pour reflÃ©ter ta rÃ©alitÃ© :
  #   - Si chez toi HP = {1,3,5}  â†’ garde ce code.
  #   - Si HP = {2,4,6}           â†’ remplace la condition (commentaire ci-dessous).
  ########################################################################
  - id: regulation_interpolation
    mode: single
    then:
      - lambda: |-
          // ============================================================
          // ðŸ”¹ DÃ©termination du mode tarifaire (HP / HC)
          // ============================================================
          // ðŸ‘‰HC = {1,3,5}, HP = {2,4,6}, 
          bool is_hp = (id(tarif).state == 2 || id(tarif).state == 4 || id(tarif).state == 6);
          float pdispo = 0.0f;  // puissance disponible pour ECS

          // ============================================================
          // ðŸ”¸ Branche HP : rÃ©gulation sur production PV / batteries
          // ============================================================
          if (is_hp) {
            if (id(etatbus_ve).state == 3) {  // Bulk
              pdispo = id(pu_prod).state - id(conso_maison).state - id(pu_clim).state - id(res_pubatt).state;
              if (pdispo < 0.0f) pdispo = 0.0f;
              id(cons_batt_cours).publish_state(id(res_pubatt).state);
              id(regul) = "HP Reg. (Bulk)";
            } 
            else if (id(etatbus_ve).state == 4 || id(etatbus_ve).state == 5) { // Absorption / Float
              pdispo = id(pu_prod).state - id(conso_maison).state - id(pu_clim).state + id(pu_batteries).state;
              if (pdispo < 0.0f) pdispo = 0.0f;
              id(cons_batt_cours).publish_state(id(pu_batteries).state * -1);
              id(regul) = "HP Reg. (Abs/Float)";
            } 
            else {
              id(regul) = "HP Reg. (Bus VE NOK)";
              id(cons_batt_cours).publish_state(0);
              pdispo = 0.0f;
            }

            ESP_LOGI("regul",
                     "HP â†’ Prod=%.0fW | Conso=%.0fW | Clim=%.0fW | Batt=%.0fW | p_dispo=%.0fW | Mode=%s",
                     id(pu_prod).state,
                     id(conso_maison).state,
                     id(pu_clim).state,
                     id(pu_batteries).state,
                     pdispo,
                     id(regul).c_str());
          }

          // ============================================================
          // ðŸ”¸ Branche HC : calcul prÃ©dictif rÃ©seau (chauffe ECS)
          // ============================================================
          else {
            const float RESEAU_CIBLE_HC = 6000.0f;  // puissance max visÃ©e sur rÃ©seau

            float conso = id(conso_maison).state;
            float clim  = id(pu_clim).state;
            float batt  = id(pu_batteries).state;   // >0 dÃ©charge, <0 charge

            // SÃ©curitÃ© anti-NaN
            if (isnan(conso)) conso = 0;
            if (isnan(clim))  clim  = 0;
            if (isnan(batt))  batt  = 0;

            // p_dispo = cible - conso_maison - pu_clim - pu_batteries
            pdispo = RESEAU_CIBLE_HC - conso - clim - batt;
            if (pdispo < 0.0f) pdispo = 0.0f;

            id(regul) = "HC Chauffe ECS";
            id(cons_batt_cours).publish_state(batt);

            ESP_LOGI("regul",
                     "HC â†’ Cible=%.0fW | Conso=%.0fW | Clim=%.0fW | Batt=%.0fW | p_dispo=%.0fW",
                     RESEAU_CIBLE_HC, conso, clim, batt, pdispo);
          }

          // ============================================================
          // ðŸ”¹ Limitation & interpolation table puissance
          // ============================================================
          pdispo = constrain(pdispo, 0.0f, id(pmax).state);
          id(p_dispo) = pdispo;

          float striac_f = 0.0f;
          for (size_t i = 1; i < id(table_puissance).size(); i++) {
            float x0 = id(table_puissance)[i-1].first;   // % Triac
            float y0 = id(table_puissance)[i-1].second;  // Puissance
            float x1 = id(table_puissance)[i].first;
            float y1 = id(table_puissance)[i].second;
            if (pdispo <= y1) {
              // interpolation linÃ©aire
              striac_f = x0 + (pdispo - y0) * (x1 - x0) / (y1 - y0);
              break;
            }
            striac_f = x1;
          }

          // SÃ©curitÃ©s & bornes
          if (isnan(striac_f)) striac_f = 0.0f;
          id(striac) = constrain(striac_f, 0.0f, 100.0f);

          // Publication MQTT / HA
          id(afpdispo).publish_state(id(p_dispo));
          id(moderegul).publish_state(id(regul));

          // ============================================================
          // ðŸ”¸ Log global synthÃ©tique (rÃ©sumÃ© clair HP/HC)
          // ============================================================
          ESP_LOGI("regul",
                   "%s | p_dispo=%.0fW | STriac=%.1f%% | Mode=%s",
                   is_hp ? "HP" : "HC",
                   pdispo, id(striac),
                   id(regul).c_str());

  ########################################################################""
    # Mode Etalonnage Increment S Triac toutes les 20 s pour laisser du temps Ã  la puissance pour se stabiliser
  - id: etalonnage_striac
    mode: restart  
    then:

      - lambda: |-
          id(striac) = 0.0;
      - while:
          condition:
            lambda: 'return id(striac) < 100.0;'  # S'arrÃªte aprÃ¨s striac = 100
          then:
            - lambda: |-
                id(striac) += 1.0; // IncrÃ©mente striac
                ESP_LOGI("striac", "Valeur striac: %.2f", id(striac));
            - light.turn_on:
                id: gradateur
                brightness: !lambda 'return id(striac) / 100.0;'  # Normalise entre 0.0 et 1.0

            - delay: 20s  # Temporisation

            - lambda: |-
                ESP_LOGI("striac", "Valeur striac: %.2f Pu ECS %.0f", id(striac), id(puecs).state);            

            - lambda: |-
                std::string mess = "{";
                mess += std::to_string(id(striac)) + ",";
                mess += std::to_string(id(puecs).state)+"}";
                ESP_LOGI("fichier", "Message: %s", mess.c_str());
                id(_log_etalonnage).execute(mess);  // Appelle le script _log_message avec le paramÃ¨tre mess

      - lambda: |-
          ESP_LOGI("striac", "Fin de l'Ã©talonnage, striac = %.2f", id(striac));

  ########################################################################""
    # ------------  Pilotage led
  - id: etat_production
    mode: single
    then:
      - if: 
          condition:
            sensor.in_range:
              id: pureseau1
              below: -50
          then:
            - output.turn_on: led_rouge
          else:
            - output.turn_off: led_rouge
            
      - if: 
          condition:
            switch.is_on: validrouteur
          then:
            - output.turn_on: led_jaune
          else:
            - output.turn_off: led_jaune
 
 ########################################################################""
  - id: calcul_relais_surprod
    mode: single
    then:
     # Si sortie triac > 20 et Pu ECS >10, signifie que le triac est sans effet, pendant plus de 60s et que
     # la tempÃ©rature de l'ECS a atteint son max (Thermostat de l'ECS dÃ©clenchÃ©)
     # alors on active le relais
     # si Pu ECS > 10 alors on desactive le relais
      - if: 
          condition:
            - lambda: 'return (id(striac)>=90 && id(puecs).state<10);'
          then:
            - delay: 300s
            - switch.turn_on: relais
            - logger.log: "Relais ActivÃ©"

      - if: 
          condition:
            - lambda: 'return id(puecs).state >= 10;'
          then:
            - switch.turn_off: relais
            - logger.log: "Relais DÃ©sactivÃ©"
 
 ########################################################################""
  - id: _log_fichier
    parameters:
      mess1: std::string  # Type explicite pour ESPHome
    then:
      - lambda: |-
          std::string mess = mess1;  // Utilise directement mess1 sans horodatage
          id(telegram_msg_buffer) = mess;
          ESP_LOGI("log_message", "Telegram buffer: %s", id(telegram_msg_buffer).c_str());
      - homeassistant.service:                
          action: notify.send_message
          data:
            entity_id: notify.log_esp176
            message: !lambda 'return id(telegram_msg_buffer).c_str();'
########################################################################""
  - id: _log_etalonnage
    parameters:
      mess1: std::string  # Type explicite pour ESPHome
    then:
      - lambda: |-
          std::string mess = mess1;  // Utilise directement mess1 sans horodatage
          id(telegram_msg_buffer) = mess;
          ESP_LOGI("log_message", "Telegram buffer: %s", id(telegram_msg_buffer).c_str());
      - homeassistant.service:                
          action: notify.send_message
          data:
            entity_id: notify.etalonnage_routeur
            message: !lambda 'return id(telegram_msg_buffer).c_str();'            