# Affichage Status bus VE
# 0=Off;1=Low Power;2=Fault;3=Bulk;4=Absorption;5=Float;6=Storage;
# 7=Equalize;8=Passthru;9=Inverting;10=Power assist;11=Power supply;252=External control

substitutions:
  device_name: "esp176-routeur"
  friendly_name: esp176
  adress_ip: "192.168.0.176"
  time_timezone: "Europe/Paris"
  # Affectation des GPIO
  GPIO_onewire: "GPIO27"
  GPIO_sda: "GPIO21"
  GPIO_scl: "GPIO22"
  GPIO_tx: "GPIO17"
  GPIO_rx: "GPIO16"  
  GPIO_Led_jaune: "GPIO26"
  GPIO_Led_rouge: "GPIO25"
  GPIO_Led_status: "GPIO32"
  GPIO_Relais: "GPIO5"
  # Dimmer
  GPIO_Gate_pin: "GPIO33"
  GPIO_ZC_pin: "GPIO34"

packages:
  jsk: !include pack_esp176/jsk.yaml
  table_pu: !include pack_esp176/table_pu.yaml

esphome:
  name: ${device_name}
  on_boot:
    priority: -100
    # Force mode auto et tempok au demarrage
    then: 
      - binary_sensor.template.publish:
          id: temperatureok
          state: ON

esp32:
  board: esp32dev
  framework:
    type: arduino
    
wifi:
  networks:
    - ssid: !secret wifi_esp
      password: !secret mdpwifi_esp
  reboot_timeout: 5min
  min_auth_mode: WPA2
  manual_ip:
    static_ip: ${adress_ip}
    gateway: 192.168.0.254
    subnet: 255.255.255.0
    dns1: !secret dns1
    dns2: !secret dns2
    
    
# Utilisez la LED bleue de l'appareil comme LED d'√©tat, qui clignotera s'il y a des avertissements (lent) ou des erreurs (rapide)
status_led:
  pin:
    number: ${GPIO_Led_status} # led jaune
    inverted: true

# Enable logging
logger:
  baud_rate: 0
  level: info

# Enable Home Assistant API
api:

ota:
  platform: esphome

web_server:
  port: 80
  version: 3

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Paris
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
      - 2.pool.ntp.org  
    on_time:
      # Mise √† jour toutes les minutes du mode HP/HC
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              auto now = id(sntp_time).now();
              if (!now.is_valid()) {
                return;
              }
              int h = now.hour;   // 0..23

              // HP : de 06:00 √† 21:59
              // HC : de 22:00 √† 05:59
              bool hp = (h >= 6 && h < 22);
              id(is_hp_hours) = hp; // En production
              //id(is_hp_hours) = !hp; // pour tester

              ESP_LOGD("horaire", "Heure = %02d:%02d ‚Üí %s", h, now.minute, hp ? "HP" : "HC");

# Protocole I2C
i2c:
  sda: ${GPIO_sda}
  scl: ${GPIO_scl}
  scan: True
  id: bus_a
  frequency: 400kHz


  
globals:
  - id: p_dispo
    type: float
    restore_value: no
    initial_value: '0'

  - id: regul
    type: std::string
    restore_value: no
    initial_value: '"Pas de r√©gulation"'

  - id: striac
    type: float
    restore_value: no
    initial_value: '0'

  - id: hc_chauffe          # m√©morise l'√©tat chauffe HC (hyst√©r√©sis)
    type: bool
    restore_value: true
    initial_value: 'false'

  # üîπ Indique si on est en heures pleines (HP) ou heures creuses (HC)
  # HP : 06:00 ‚Üí 22:00  ;  HC : 22:00 ‚Üí 06:00
  - id: is_hp_hours
    type: bool
    restore_value: no
    initial_value: 'true'

  # stocke temporairement le message √† envoyer √† telegram
  - id: telegram_msg_buffer
    type: std::string
    restore_value: no
    initial_value: '""'

# Sonde Temperature Dallas
one_wire:
  - platform: gpio  
    pin: ${GPIO_onewire}

# d√©claration des modes de fonctionnement dans des "input select"
select:
  - platform: template
    name: "Mode_Fonctionnement_routeur"
    optimistic: true
    restore_value: true
    options:
      - Auto
      - Manu
      - Arret
      - Etalonnage
    id: _Mode_Fonctionnement_routeur
    on_value: 
      then:
        - lambda: |-
            char mess[128];
            snprintf(mess, sizeof(mess), "Mode Fonctionnement Routeur: %s", id(_Mode_Fonctionnement_routeur).current_option());
            ESP_LOGI("fichier", "Message: %s", mess);
            id(_log_fichier).execute(mess);  // Appelle le script _log_fichier avec le param√®tre mess      
        # Passage en mode √©talonnage
        - if:
            condition:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option() == "Etalonnage";'
            then:
              - script.execute: etalonnage_striac
        # Passage en mode Manu on remet √† Zero le valid Routeur et la consigne Manu
        - if:
            condition:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option()  == "Manu";'
            then:
              - lambda: |-
                  id(ctriac_manu).publish_state(0);
              - switch.turn_off: validrouteur
        # Passage dans tous les modes on met √† z√©ro le triac
        - lambda: |-
            id(striac) = 0;
        - light.turn_off:
            id: gradateur
        - script.execute: calcul_injection_hp     

binary_sensor:
  #Etat de la connection
  - platform: status
    name: "Status"
  
  - platform: template
    name: "Temp Ok"
    id: temperatureok
  
  - platform: template
    name: "Seuil Prod Ok"
    id: seuil_prod_ok

  - platform: template
    name: "Seuil SOC Ok"
    id: seuil_soc_ok
  
# Input Number
number:
  # seuil SOC validation routeur
  - platform: template
    name: "Consigne Triac en manu"
    id: ctriac_manu
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 100
    unit_of_measurement: "%"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # Max sortie triac
  - platform: template
    name: "Puissance Max Triac"
    id: pmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 10
    max_value: 3000
    unit_of_measurement: "W"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # Seuil MAX temperature
  - platform: template
    name: "T Max"
    id: tmax
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 75
    unit_of_measurement: "C¬∞"
    step: 0.1
    icon: mdi:arrow-collapse-vertical

  # Consigne R√©gul sur Puissance Batteries en mode Bulk
  - platform: template
    name: "Reserve Charge Batteries"
    id: res_pubatt
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 2500
    unit_of_measurement: "W"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # seuil SOC validation routeur
  - platform: template
    name: "Seuil SOC"
    id: seuil_soc
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 100
    unit_of_measurement: "%"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # seuil Production Photovoltaique de validation routeur 
  - platform: template
    name: "Seuil Production Val Routeur"
    id: seuil_prod
    optimistic: true
    restore_value: true
    mode: box
    min_value: 100
    max_value: 3000
    unit_of_measurement: "W"
    step: 1
    icon: mdi:arrow-collapse-vertical

  # Simul Vol ECS
  - platform: template
    name: "Simul Vol ECS"
    id: volume_ecs_ha_simul
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 200
    unit_of_measurement: "L"
    step: 1
    icon: mdi:arrow-collapse-vertical
    
  - platform: template
    name: "Seuil Bas ECS (L)"
    id: seuil_bas_ha
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 200       # ballon 200L ‚Üí √† adapter si besoin
    unit_of_measurement: "L"
    step: 5
    icon: mdi:water

  - platform: template
    name: "Seuil Haut ECS (L)"
    id: seuil_haut_ha
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 200
    unit_of_measurement: "L"
    step: 5
    icon: mdi:water

sensor:
  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
    device_class: ""
    
  ############### TEMPLATE  ######################"
  # Affichage dans HA et sur l'afficheur
  # Puissance lue par le JSk- N√©gative en injection/Positive en soutirage
  - platform: template
    name: "Pu Reseau"
    id: pureseau1
    unit_of_measurement: "W"
    state_class: "measurement"
    accuracy_decimals: 0

  # Sortie triac de 0√†100%
  - platform: template
    name: "Sortie Triac"
    id: afstriac
    unit_of_measurement: "%"
    state_class: "measurement"  
    accuracy_decimals: 2

  # Pu disponible
  - platform: template
    name: "Pu Disponible"
    id: afpdispo
    unit_of_measurement: "W"
    state_class: "measurement"
    accuracy_decimals: 0

  # Sensor Intermediaire pour synoptique
  - platform: template
    name: "Cons batt en Cours"
    id: cons_batt_cours
    state_class: "measurement"
    unit_of_measurement: "W"
    accuracy_decimals: 0

  # Lecture dans HA

  - platform: homeassistant
    entity_id: sensor.victron_mqtt_c0619ab1db0d_vebus_276_vebus_inverter_output_power_l1
    id: conso_maison
    internal: true
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: homeassistant
    entity_id: sensor.victron_mqtt_c0619ab1db0d_battery_277_battery_power
    id: pu_batteries
    internal: true
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
 
  - platform: homeassistant
    entity_id: sensor.mp2_production_solaire_totale
    id: pu_prod
    internal: true
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: homeassistant
    entity_id: sensor.victron_mqtt_c0619ab1db0d_battery_277_battery_soc
    id: soc
    internal: true
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: homeassistant
    entity_id: sensor.ecocompteur_clim
    id: pu_clim
    internal: true

  # Sonde Temperature radiateur
  - platform: dallas_temp
    address: 0xeb012112e461b128
    name: "Temp triac"
    id: temp_triac
    update_interval: 60s
    filters:
      - filter_out: NAN

  # Temp√©rature ECS HA
  - platform: homeassistant
    id: temp_ecs_ha
    entity_id: sensor.esp139_ecs_temp_ecs
    name: "Temp√©rature ECS HA"
  # Volume d'eau chaude dispo (en L) mesur√© par ESP126

  - platform: homeassistant
    id: volume_ecs_ha
    entity_id: sensor.esp139_ecs_ballon_volume_eau_chaude
    name: "Volume ECS HA"

# d√©claration des "text_sensors"
text_sensor:
  - platform: template
    name: "Mode Regulation"
    id: moderegul

  - platform: homeassistant
    entity_id: sensor.victron_mqtt_c0619ab1db0d_vebus_276_vebus_inverter_state
    id: etatbus_ve
    internal: true

switch:
  - platform: gpio
    name: "Relais"
    pin: ${GPIO_Relais}
    id: relais

  - platform: template
    name: "Valid Routeur"    
    id: validrouteur
    optimistic: true
    restore_mode: always_on

  - platform: restart
    name: "Restart"

output:
  #LEDS --------------------------------------
  - id: led_jaune
    platform: gpio
    pin: ${GPIO_Led_jaune} 

  - id: led_rouge
    platform: gpio
    pin: ${GPIO_Led_rouge}

  # Pilotage du Dimmer
  - platform: ac_dimmer 
    id: ecs
    gate_pin: ${GPIO_Gate_pin}
    method: leading
    zero_cross_pin:
      number: ${GPIO_ZC_pin} 
      mode:
        input: true
      inverted: yes
    min_power: 5%

light:
  - platform: monochromatic
    name: "STriac"
    output: ecs
    id: gradateur
    default_transition_length: 50ms

# Affichage
display:
  - platform: lcd_pcf8574
    dimensions: 20x4
    address: 0x27
    update_interval: 20s  # Plus espac√© pour all√©ger la charge CPU
    lambda: |-
      char ligne0[21];
      char ligne1[21];
      char ligne2[21];
      char ligne3[21];

      snprintf(ligne0, sizeof(ligne0), "Pr=%0.0fW Pe=%0.0fW", id(pureseau1).state, id(puecs).state);
      snprintf(ligne1, sizeof(ligne1), "Tr=%0.1f%% V:%s", id(striac), id(validrouteur).state ? "OK" : "NOK");
      snprintf(ligne2, sizeof(ligne2), "Tp=%0.1fc E:%s", id(temp_triac).state, id(temperatureok).state ? "OK" : "NOK");
      snprintf(ligne3, sizeof(ligne3), "Mode:%s", id(_Mode_Fonctionnement_routeur).current_option());

      it.print(0, 0, ligne0);
      it.print(0, 1, ligne1);
      it.print(0, 2, ligne2);
      it.print(0, 3, ligne3);

interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
              // HP de 06:00 √† 22:00, sinon HC
              return id(is_hp_hours);   // true = HP, false = HC
          then:
            - script.execute: calcul_injection_hp
          else:
            - script.execute: calcul_injection_hc

  - interval: 5s
    then:      
      - script.execute: etat_production
      - script.execute: calcul_relais_surprod      

 ########################################################################
script:
  ########################################################################
  # üîπ Script : calcul_injection_hp
  ########################################################################
  - id: calcul_injection_hp
    mode: single
    then:
      - lambda: |-
          // ============================================================
          // üß≠ √âVALUATION DES CONDITIONS DE D√âMARRAGE
          // ============================================================

          // ‚úÖ V√©rifie si la production solaire est suffisante
          bool prod_ok = (id(pu_prod).state > id(seuil_prod).state);
          id(seuil_prod_ok).publish_state(prod_ok);

          // ‚úÖ V√©rifie si le SOC est sup√©rieur au seuil (avec hysteresis de 2%)
          bool soc_ok = false;
          if (id(soc).state >= id(seuil_soc).state) {
            soc_ok = true;
          } else if (id(soc).state < (id(seuil_soc).state - 2)) {
            soc_ok = false;
          }
          id(seuil_soc_ok).publish_state(soc_ok);

          // ‚úÖ V√©rifie la temp√©rature du radiateur triac
          bool temp_ok = (id(temp_triac).state < (id(tmax).state - 2));
          if (!temp_ok) {
            id(temperatureok).publish_state(false);
          } else {
            id(temperatureok).publish_state(true);
          }

          ESP_LOGI("HP", 
            "Check HP ‚Üí Prod=%.0fW (Seuil=%.0f) | SOC=%.1f%% (Seuil=%.1f) | TempTriac=%.1f¬∞C (Tmax=%.1f¬∞C)",
            id(pu_prod).state, id(seuil_prod).state,
            id(soc).state, id(seuil_soc).state,
            id(temp_triac).state, id(tmax).state
          );

      # 1Ô∏è‚É£ Conditions NOK ou mode Arret ‚Üí arr√™t complet
      - if:
          condition:
            or:
              # Cas 1 : Mode Arret
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option() == "Arret";'
              # Cas 2 : Mode Auto mais conditions NOK
              - and:
                  - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option() == "Auto";'
                  - or:
                      - switch.is_off: validrouteur
                      - binary_sensor.is_off: temperatureok
                      - binary_sensor.is_off: seuil_prod_ok
                      - binary_sensor.is_off: seuil_soc_ok
          then:
            - lambda: |-
                id(striac) = 0;
                id(moderegul).publish_state("OFF");
                id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);
                ESP_LOGW("HP", "‚ö†Ô∏è R√©gulation OFF : conditions NOK ou arr√™t manuel.");
            - light.turn_off: gradateur

      # 2Ô∏è‚É£ Mode Auto + toutes conditions OK ‚Üí r√©gulation active
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option() == "Auto";'
              - switch.is_on: validrouteur
              - binary_sensor.is_on: seuil_prod_ok
              - binary_sensor.is_on: temperatureok
              - binary_sensor.is_on: seuil_soc_ok
          then:
            - logger.log:
                format: "‚úÖ Conditions OK (HP) ‚Üí R√©gulation interpolation active"
                level: INFO
            - script.execute: regulation_interpolation

            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(striac) / 100.0f;

      # 3Ô∏è‚É£ Mode Manuel ‚Üí application directe de la consigne
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option() == "Manu";'
              - switch.is_on: validrouteur
          then:
            - lambda: |-
                // Application directe de la consigne manuelle
                id(striac) = id(ctriac_manu).state;
                id(afpdispo).publish_state(0);
                id(moderegul).publish_state("Manu");
                id(cons_batt_cours).publish_state(0);
                ESP_LOGI("HP", "üß© Mode MANU ‚Üí Triac forc√© √† %.1f%%", id(striac));
            - light.turn_on:
                id: gradateur
                brightness: !lambda |-
                  return id(striac) / 100.0f;

      # Publication de la valeur du triac (affichage + MQTT)
      - lambda: |-
          id(afstriac).publish_state(id(striac));

  ########################################################################
  # üîπ Script : calcul_injection_hc (avec hyst√©r√©sis ECS)
  ########################################################################

  - id: calcul_injection_hc
    mode: single
    then:
      - lambda: |-
          float volume_ecs       = id(volume_ecs_ha).state;        // en L
          float seuil_bas_vol    = id(seuil_bas_ha).state;         // en L
          float seuil_haut_vol   = id(seuil_haut_ha).state;        // en L
          float puissance_reseau = id(pureseau1).state;

          // ‚úÖ V√©rifie la temp√©rature du triac
          bool temperature_ok = (id(temp_triac).state < (id(tmax).state - 2));
          id(temperatureok).publish_state(temperature_ok);

          // ‚úÖ D√©tection √©tat ECS (sur le volume)
          bool ecs_froide = (volume_ecs <  seuil_bas_vol);   // pas assez d'eau chaude
          bool ecs_chaude = (volume_ecs >= seuil_haut_vol);  // volume confortable

          // ‚úÖ V√©rifie l'injection r√©seau (puissance n√©gative)
          bool injection_autorisee = (puissance_reseau >= -200);

          ESP_LOGI("HC",
            "Check HC ‚Üí Volume ECS=%.0fL (%.0f‚Äì%.0fL) | P_R√©seau=%.0fW | TempTriac=%.1f¬∞C | TempOK=%d | Valid=%d",
            volume_ecs, seuil_bas_vol, seuil_haut_vol,
            puissance_reseau, id(temp_triac).state,
            temperature_ok, id(validrouteur).state
          );

      # 1Ô∏è‚É£ Conditions NOK ou mode Arret ‚Üí arr√™t complet
      - if:
          condition:
            or:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option() == "Arret";'
              - and:
                  - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option()  == "Auto";'
                  - or:
                      - switch.is_off: validrouteur
                      - binary_sensor.is_off: temperatureok
          then:
            - lambda: |-
                id(striac) = 0;
                id(hc_chauffe) = false;
                id(moderegul).publish_state("HC OFF - Conditions NOK ou arr√™t");
                id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);
                ESP_LOGW("HC", "‚ö†Ô∏è Chauffe OFF : conditions NOK ou arr√™t manuel.");
            - light.turn_off: gradateur

      # 2Ô∏è‚É£ Mode Auto + toutes conditions OK ‚Üí r√©gulation interpolation (HC) sur le volume
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option()  == "Auto";'
              - switch.is_on: validrouteur
              - binary_sensor.is_on: temperatureok
          then:
            - lambda: |-
                float volume_ecs       = id(volume_ecs_ha).state;        // en L
                float seuil_bas_vol    = id(seuil_bas_ha).state;         // en L
                float seuil_haut_vol   = id(seuil_haut_ha).state;        // en L
                float puissance_reseau = id(pureseau1).state;

                // Puissance dispo locale pour ce calcul HC
                float pdispo = 0.0f;

                // ---- Test de l'√©tat bus VE ----
                if (id(etatbus_ve).state == "Bulk") {  // Bulk
                  pdispo = id(pu_prod).state
                           - id(conso_maison).state
                           - id(pu_clim).state
                           - id(res_pubatt).state;
                  if (pdispo < 0.0f) pdispo = 0.0f;
                  id(cons_batt_cours).publish_state(id(res_pubatt).state);
                  id(regul) = "HC Reg. (Bulk)";
                }
                else if (id(etatbus_ve).state == "Absorption" || id(etatbus_ve).state == "Float") { // Absorption / Float
                  pdispo = id(pu_prod).state
                           - id(conso_maison).state
                           - id(pu_clim).state
                           + id(pu_batteries).state;
                  if (pdispo < 0.0f) pdispo = 0.0f;
                  id(cons_batt_cours).publish_state(id(pu_batteries).state * -1);
                  id(regul) = "HC Reg. (Abs/Float)";
                }
                else {
                  pdispo = 0.0f;
                  id(cons_batt_cours).publish_state(0);
                  id(regul) = "HC Reg. (Bus VE NOK)";
                }

                // ---- Logique ECS HC avec hyst√©r√©sis ----
                bool injection_autorisee = (puissance_reseau >= -200);
                bool ecs_froide          = (volume_ecs <  seuil_bas_vol);
                bool ecs_chaude          = (volume_ecs >= seuil_haut_vol);
                bool chauffe_active      = id(hc_chauffe);  // global bool ‚Üí OK

                // S√©curit√© injection
                if (!injection_autorisee) {
                  id(striac)     = 0.0f;
                  id(hc_chauffe) = false;
                  id(moderegul).publish_state("HC S√©curit√© Injection OFF");
                  ESP_LOGI("HC", "‚õî Injection d√©tect√©e (%.0f W) ‚Üí Chauffe arr√™t√©e", puissance_reseau);
                } else {
                  if (ecs_froide) {
                    // Volume trop faible ‚Üí d√©marrage
                    id(hc_chauffe) = true;
                    id(moderegul).publish_state("HC Chauffe active (Volume bas)");
                    ESP_LOGI("HC", "üî• Volume ECS %.0fL < %.0fL ‚Üí D√©marrage chauffe (hyst√©r√©sis ON)",
                             volume_ecs, seuil_bas_vol);
                  }
                  else if (chauffe_active && !ecs_chaude) {
                    // Chauffe en cours ‚Üí maintien
                    id(moderegul).publish_state("HC Chauffe maintenue");
                    ESP_LOGI("HC", "‚ô®Ô∏è Volume ECS %.0fL (entre %.0f et %.0fL) ‚Üí Maintien chauffe",
                             volume_ecs, seuil_bas_vol, seuil_haut_vol);
                  }
                  else if (ecs_chaude) {
                    // Volume confortable ‚Üí arr√™t
                    id(striac)     = 0.0f;
                    id(hc_chauffe) = false;
                    id(moderegul).publish_state("HC Volume OK - Chauffe OFF");
                    ESP_LOGI("HC", "‚úÖ Volume ECS %.0fL ‚â• %.0fL ‚Üí Chauffe arr√™t√©e",
                             volume_ecs, seuil_haut_vol);
                  }
                  else {
                    // Zone neutre ‚Üí OFF
                    id(striac)     = 0.0f;
                    id(hc_chauffe) = false;
                    id(moderegul).publish_state("HC Attente (Volume neutre)");
                    ESP_LOGI("HC", "üïì Volume ECS %.0fL dans zone neutre ‚Üí Chauffe OFF",
                             volume_ecs);
                  }
                }

                // On limite et pousse quelques valeurs en sortie
                pdispo = constrain(pdispo, 0.0f, id(pmax).state);
                id(p_dispo) = pdispo;             // global
                id(afstriac).publish_state(id(striac));
                id(afpdispo).publish_state(id(p_dispo));
                // cons_batt_cours d√©j√† mis plus haut selon le mode


            - light.turn_on:
                id: gradateur
                brightness: !lambda 'return id(striac) / 100.0f;'

      # 3Ô∏è‚É£ Mode Manuel ‚Üí inchang√©
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_routeur).current_option()  == "Manu";'
              - switch.is_on: validrouteur
          then:
            - delay: 500ms
            - lambda: |-
                id(striac) = id(ctriac_manu).state;
                id(hc_chauffe) = false;
                id(moderegul).publish_state("HC Mode Manuel");
                id(afpdispo).publish_state(0);
                id(cons_batt_cours).publish_state(0);
                ESP_LOGI("HC", "üß© Mode MANU ‚Üí Triac forc√© √† %.1f%%", id(striac));
            - light.turn_on:
                id: gradateur
                brightness: !lambda 'return id(striac) / 100.0f;'
            - lambda: |-
                id(afstriac).publish_state(id(striac));

  ########################################################################
  # üîπ Script : regulation_interpolation (commun HP + HC)
  ########################################################################
  - id: regulation_interpolation
    mode: single
    then:
      - lambda: |-
          // üîπ D√©termination du mode HP / HC √† partir de l'heure
          bool is_hp = id(is_hp_hours);  // true = HP (06‚Äì22h), false = HC (22‚Äì06h)
          float pdispo = 0.0f;  // puissance disponible pour ECS

          // üî∏ Branche HP : r√©gulation sur production PV / batteries
          if (is_hp) {
            if (id(etatbus_ve).state == "Bulk") {  // Bulk
              pdispo = id(pu_prod).state - id(conso_maison).state - id(pu_clim).state - id(res_pubatt).state;
              if (pdispo < 0.0f) pdispo = 0.0f;
              id(cons_batt_cours).publish_state(id(res_pubatt).state);
              id(regul) = "HP Reg. (Bulk)";
            } 
            else if (id(etatbus_ve).state == "Absorption" || id(etatbus_ve).state == "Float") { // Absorption / Float
              pdispo = id(pu_prod).state - id(conso_maison).state - id(pu_clim).state + id(pu_batteries).state;
              if (pdispo < 0.0f) pdispo = 0.0f;
              id(cons_batt_cours).publish_state(id(pu_batteries).state * -1);
              id(regul) = "HP Reg. (Abs/Float)";
            } 
            else {
              id(regul) = "HP Reg. (Bus VE NOK)";
              id(cons_batt_cours).publish_state(0);
              pdispo = 0.0f;
            }

            ESP_LOGI("regul",
                     "HP ‚Üí Prod=%.0fW | Conso=%.0fW | Clim=%.0fW | Batt=%.0fW | p_dispo=%.0fW | Mode=%s",
                     id(pu_prod).state,
                     id(conso_maison).state,
                     id(pu_clim).state,
                     id(pu_batteries).state,
                     pdispo,
                     id(regul).c_str());
          }
          // üî∏ Branche HC : calcul pr√©dictif r√©seau (chauffe ECS)
          else {
            const float RESEAU_CIBLE_HC = 6000.0f;  // puissance max vis√©e sur r√©seau

            float conso = id(conso_maison).state;
            float clim  = id(pu_clim).state;
            float batt  = id(pu_batteries).state;   // >0 d√©charge, <0 charge

            if (isnan(conso)) conso = 0;
            if (isnan(clim))  clim  = 0;
            if (isnan(batt))  batt  = 0;

            // p_dispo = cible - conso_maison - pu_clim - pu_batteries
            pdispo = RESEAU_CIBLE_HC - conso - clim - batt;
            if (pdispo < 0.0f) pdispo = 0.0f;

            id(regul) = "HC Chauffe ECS";
            id(cons_batt_cours).publish_state(batt);

            ESP_LOGI("regul",
                     "HC ‚Üí Cible=%.0fW | Conso=%.0fW | Clim=%.0fW | Batt=%.0fW | p_dispo=%.0fW",
                     RESEAU_CIBLE_HC, conso, clim, batt, pdispo);
          }

          // üîπ Limitation & interpolation table puissance
          pdispo = constrain(pdispo, 0.0f, id(pmax).state);
          id(p_dispo) = pdispo;

          float striac_f = 0.0f;
          for (size_t i = 1; i < id(table_puissance).size(); i++) {
            float x0 = id(table_puissance)[i-1].first;   // % Triac
            float y0 = id(table_puissance)[i-1].second;  // Puissance
            float x1 = id(table_puissance)[i].first;
            float y1 = id(table_puissance)[i].second;
            if (pdispo <= y1) {
              // interpolation lin√©aire
              striac_f = x0 + (pdispo - y0) * (x1 - x0) / (y1 - y0);
              break;
            }
            striac_f = x1;
          }

          if (isnan(striac_f)) striac_f = 0.0f;
          id(striac) = constrain(striac_f, 0.0f, 100.0f);

          id(afpdispo).publish_state(id(p_dispo));
          id(moderegul).publish_state(id(regul));

          ESP_LOGI("regul",
                   "%s | p_dispo=%.0fW | STriac=%.1f%% | Mode=%s",
                   is_hp ? "HP" : "HC",
                   pdispo, id(striac),
                   id(regul).c_str());

  ########################################################################
  # Mode Etalonnage Increment S Triac
  ########################################################################
  - id: etalonnage_striac
    mode: restart  
    then:
      - lambda: |-
          id(striac) = 0.0;
      - while:
          condition:
            lambda: 'return id(striac) < 100.0;'  # S'arr√™te apr√®s striac = 100
          then:
            - lambda: |-
                id(striac) += 1.0; // Incr√©mente striac
                ESP_LOGI("striac", "Valeur striac: %.2f", id(striac));
            - light.turn_on:
                id: gradateur
                brightness: !lambda 'return id(striac) / 100.0;'  # Normalise entre 0.0 et 1.0

            - delay: 20s  # Temporisation

            - lambda: |-
                ESP_LOGI("striac", "Valeur striac: %.2f Pu ECS %.0f", id(striac), id(puecs).state);            

            - lambda: |-
                std::string mess = "{";
                mess += std::to_string(id(striac)) + ",";
                mess += std::to_string(id(puecs).state)+"}";
                ESP_LOGI("fichier", "Message: %s", mess.c_str());
                id(_log_etalonnage).execute(mess);

      - lambda: |-
          ESP_LOGI("striac", "Fin de l'√©talonnage, striac = %.2f", id(striac));

  ########################################################################
  # ------------  Pilotage led
  ########################################################################
  - id: etat_production
    mode: single
    then:
      - if: 
          condition:
            sensor.in_range:
              id: pureseau1
              below: -50
          then:
            - output.turn_on: led_rouge
          else:
            - output.turn_off: led_rouge
            
      - if: 
          condition:
            switch.is_on: validrouteur
          then:
            - output.turn_on: led_jaune
          else:
            - output.turn_off: led_jaune
 
  ########################################################################
  - id: calcul_relais_surprod
    mode: single
    then:
      - if: 
          condition:
            - lambda: 'return (id(striac)>=90 && id(puecs).state<10);'
          then:
            - delay: 300s
            - switch.turn_on: relais
            - logger.log: "Relais Activ√©"

      - if: 
          condition:
            - lambda: 'return id(puecs).state >= 10;'
          then:
            - switch.turn_off: relais
            - logger.log: "Relais D√©sactiv√©"
 
  ########################################################################
  - id: _log_fichier
    parameters:
      mess1: std::string
    then:
      - lambda: |-
          std::string mess = mess1;
          id(telegram_msg_buffer) = mess;
          ESP_LOGI("log_message", "Telegram buffer: %s", id(telegram_msg_buffer).c_str());
      - homeassistant.service:                
          action: notify.send_message
          data:
            entity_id: notify.log_esp176
            message: !lambda 'return id(telegram_msg_buffer).c_str();'

  ########################################################################
  - id: _log_etalonnage
    parameters:
      mess1: std::string
    then:
      - lambda: |-
          std::string mess = mess1;
          id(telegram_msg_buffer) = mess;
          ESP_LOGI("log_message", "Telegram buffer: %s", id(telegram_msg_buffer).c_str());
      - homeassistant.service:                
          action: notify.send_message
          data:
            entity_id: notify.etalonnage_routeur
            message: !lambda 'return id(telegram_msg_buffer).c_str();'
