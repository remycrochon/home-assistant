substitutions:
  device_name: "esp178-esp32-piscine"
  friendly_name: esp178
  adress_ip: "192.168.0.178"
  time_timezone: "Europe/Paris"
  
esphome:
  name: ${device_name}
  platform: ESP32
  board: esp32dev
  project:
    name: "rem81.esp178-esp32-piscine"
    version: "0.0.0"

wifi:
  networks:
    - ssid: !secret wifi
      password: !secret mdpwifi
  reboot_timeout: 5min

  manual_ip:
    static_ip: ${adress_ip}
    gateway: 192.168.0.254
    subnet: 255.255.255.0
    dns1: 192.168.0.254
    
# Utilisez la LED bleue de l'appareil comme LED d'état, qui clignotera s'il y a des avertissements (lent) ou des erreurs (rapide)
status_led:
  pin:
    number: GPIO23
    inverted: true

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:

ota:
  platform: esphome
captive_portal:
 
web_server:
  port: 80

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Paris
    servers:
     - 0.pool.ntp.org
     - 1.pool.ntp.org
     - 2.pool.ntp.org

# Connection Bus i2c (Afficheur, EZO,...)
i2c:
  sda: 21
  scl: 22
  scan: true
  id: bus_a

# Connection sonde(s) de température DS18b20
one_wire:
  - platform: gpio  
    pin: GPIO9
# déclaration des variables "globals"
globals:
    # temps de fonctionnement en début de pompage avant prise en compte de la mesure de température
    # en secondes
    - id: g_tps_mesure_temp
      type: float
      initial_value: '60'
    - id: g_memoire_temp_eau
      type: float
      restore_value: yes
    - id: flag_tempo_ppe_filtre
      type: bool

    - id: g_tps_injection_ph_moins
      type: float
      restore_value: no
    # mémorise la durée de filtation dans les différents modes de fonctionnement
    - id: g_tps_filtration
      type: float
      restore_value: no

# Limite haute du temps de filtration "en heure"
    - id: g_temps_max_filtration
      type: float
      initial_value: '23'
# Limite basse du temps de filtration (en heure)
    - id: g_temps_min_filtration
      type: float
      initial_value: '5'
# Paliers temperature/Temps filtration avec le mode "Palier"
  # Seuils Température en °C
    - id: g_temp_palier1
      type: float
      initial_value: '9'
    - id: g_temp_palier2
      type: float
      initial_value: '12'
    - id: g_temp_palier3
      type: float
      initial_value: '17'
    - id: g_temp_palier4
      type: float
      initial_value: '24' 
  # nb d'heures de filtration (en h)
    - id: g_tps_palier1
      type: float
      initial_value: '1'      
    - id: g_tps_palier2
      type: float
      initial_value: '4'
    - id: g_tps_palier3
      type: float
      initial_value: '6'
    - id: g_tps_palier4
      type: float
      initial_value: '8'
    - id: g_tps_palier5
      type: float
      initial_value: '10'

# Constantes utilisées dans le mode "Abaque"  
#    abaque_a: float = 0.00335
#    abaque_b: float = -0.14953
#    abaque_c: float = 2.43489
#    abaque_d: float = -10.72859

    - id: g_abaque_a
      type: float
      initial_value: '0.00335'
    - id: g_abaque_b
      type: float
      initial_value: '-0.14953'
    - id: g_abaque_c
      type: float
      initial_value: '2.43489'
    - id: g_abaque_d
      type: float
      initial_value: '-10.72859'

# Variables intermediaires utilisées dans le calcul "heure debut et fin"
    - id: g_hh
      type: int
    - id: g_mm
      type: int
    - id: g_ss
      type: int

# déclaration des modes de fonctionnement dans des "input select"
select:
  - platform: template
    name: "${friendly_name}_Mode_Fonctionnement_filtration"
    optimistic: true
    restore_value: true
    options:
      - Palier
      - Classique
      - Abaque
      - Horaire
      - Ma_f
      - At_f
    id: _Mode_Fonctionnement_filtration
    on_value: 
      then:
        - logger.log:
            format: "Mode Fonct Filtration --> %s"
            args: [ 'id(_Mode_Fonctionnement_filtration).state.c_str()' ]
            level: INFO
        - script.execute: Fonctionnement_filtration

  - platform: template
    name: "${friendly_name}_Mode_Fonctionnement_regul_ph"
    optimistic: true
    restore_value: true
    options:
      - Auto
      - Ma_f
      - At_f
    id: _Mode_Fonctionnement_regul_ph
    on_value: 
      then:
        - logger.log:
            format: "Mode Fonct Regul pH --> %s"
            args: [ 'id(_Mode_Fonctionnement_regul_ph).state.c_str()' ]
            level: INFO        
        - script.stop: _regul_ph   
        - delay: 1s            
        - script.execute: _regul_ph        

  - platform: template
    name: "${friendly_name}_Mode_Fonct_appoint_eau"
    optimistic: true
    restore_value: true
    options:
      - Auto
      - Ma_f
      - At_f
    id: _Mode_Fonctionnement_regul_eau
    on_value: 
      then:
        - logger.log:
            format: "Mode Fonct Regul Eau --> %s"
            args: [ 'id(_Mode_Fonctionnement_regul_eau).state.c_str()' ]
            level: INFO        
        - script.stop: _regul_eau
        - delay: 1s            
        - script.execute: _regul_eau          

# Input Number
number:
  # Simulation Temp eau
  - platform: template
    name: "${friendly_name}_simule_Temp"
    id: temp_eau
    optimistic: true
    restore_value: true
    mode: box
    min_value: -10
    max_value: 50
    device_class: temperature
    step: 0.1  
  # Simulation Temp eau

  - platform: template
    name: "${friendly_name}_coeff_Filtration"
    id: coeff_filtration
    optimistic: true
    restore_value: true
    mode: box
    min_value: 50
    max_value: 150
    unit_of_measurement: "%"
    step: 1
    icon: mdi:percent

  # Simulation Niveau pH
  - platform: template
    name: "${friendly_name}_simule_pH"
    id: ph_ezo
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 10
    unit_of_measurement: "pH"
    step: 0.1  

  # Cible Niveau pH
  - platform: template
    name: "${friendly_name}_pH_Cible"
    id: _ph_cible
    optimistic: true
    restore_value: true
    mode: box
    min_value: 7
    max_value: 7.6
    unit_of_measurement: "pH"
    step: 0.1

  - platform: template
    name: "${friendly_name}_debit_ppe_ph_moins"
    id: _debit_ppe_moins
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 7.2
    unit_of_measurement: "l/h"
    step: 0.1

  - platform: template
    name: "${friendly_name}_taux_concentration_ph_moins"
    id: _taux_concentration_ph_moins
    optimistic: true
    restore_value: true
    mode: box
    min_value: 0
    max_value: 100
    unit_of_measurement: "%"
    step: 1
    icon: mdi:percent

binary_sensor:
#Etat de la connection
  - platform: status
    name: "${friendly_name}_Status"

# calcul des niveaux piscine
# Si LSL ou LSH recouvert alors True sinon False
  - platform: template
    name: "${friendly_name}_niv_haut"
    id: niv_haut
      
  - platform: template
    name: "${friendly_name}_niv_inter"
    id: niv_inter

  - platform: template
    name: "${friendly_name}_niv_bas"
    id: niv_bas

  - platform: template
    name: "${friendly_name}_niv_defaut"
    id: niv_defaut

  # Entrée logique permettant de lire le BP I00 de la carte
  - platform: gpio
    pin:
      number: GPIO00
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_bp1"

  # Entrées logiques permettant de lire des contacts exterieurs
  - platform: gpio
    pin:
      number: GPIO16
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_volet_ferme"
    id: volet_ferme

  - platform: gpio
    pin:
      number: GPIO17
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_tp_plein_lsh"
    id: lsh

  - platform: gpio
    pin:
      number: GPIO04
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_tp_plein_lsl"
    id: lsl

  - platform: gpio
    pin:
      number: GPIO18
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_ETOR4"

  - platform: gpio
    pin:
      number: GPIO5
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_ETOR5"

  - platform: gpio
    pin:
      number: GPIO19
      inverted: True
      mode:
        input: true
        pullup: true
    name: "${friendly_name}_ETOR6"


# Définiton de l'heure Pivot   
datetime:
  - platform: template
    id: heure_pivot
    type: time
    name: "${friendly_name}_heure_pivot"
    optimistic: yes
    #initial_value: "13:30:00"
    restore_value: true

  - platform: template
    id: h_debut
    type: time
    name: "${friendly_name}_h_debut"
    optimistic: yes
    initial_value: "00:00:00"
    restore_value: true
    #disabled_by_default: true # Ne pas afficher dans HA #ne fonctionne pas

  - platform: template
    id: h_fin
    type: time
    name: "${friendly_name}_h_fin"
    optimistic: yes
    initial_value: "00:00:00"
    restore_value: true
    #disabled_by_default: true # Ne pas afficher dans HA

  - platform: template
    id: debut_mode_horaire
    type: time
    name: "${friendly_name}_debut_mode_horaire"
    optimistic: yes
    restore_value: true

  - platform: template
    id: duree_mode_horaire
    type: time
    name: "${friendly_name}_duree_mode_horaire"
    optimistic: yes
    restore_value: true

sensor:
  - platform: dallas_temp
    address: 0x82012111efe81d28
    name: "${friendly_name}_temperature_eau"
    id: old_temp_eau
    filters:
      - filter_out: 0.0

  # Mesure du pH
  # Procédure étalonnage:
    # Mettre 1 s dans "update interval"
    # ainsi on moyenne sur 15 s avec un affichage toutes les 5s 
    # 1-Faire une mesure avec solution étalon de 4.0
    # 2-Attendre 2 à 3 minutes que ca se stabilise
    # 3-relever la valeur du pH
    # 4-Toujours bien rincer la sonde à l'eau déminéralisée entre deux solutions
    # Refaire étapes 1 à 3 avec une solution étalon de 6.86
    # Puis avec une solution étalon de 9.18
    # Saisir les valeurs relevés dans "Calibrate_linear"
    # Remettre 60 s dans "update interval"
    # Compiler
  # Fin procédure étalonnage
  - platform: ezo
    id: old_ph_ezo
    name: "${friendly_name}_ph_ezo"
    address: 99
    unit_of_measurement: "pH"
    accuracy_decimals: 2
    update_interval: 60s
  #  moyenne sur 15 mn-affichage toutes les 5mn
    filters:
      - sliding_window_moving_average:
          window_size: 15
          send_every: 5
          send_first_at: 1
  # Etalonné le 15 juin 2024          
      - calibrate_linear:
        - 4.665 -> 4.0
        - 7.482 -> 6.86
        - 9.505 -> 9.18          
  # Etalonné le 28 juin 2023          
  #    - calibrate_linear:
  #      - 4.547 -> 4.0
  #      - 7.282 -> 6.86
  #      - 9.447 -> 9.18
  # Etalonné le 6 juillet 2022          
  #    - calibrate_linear:
  #      - 4.44 -> 4.0
  #      - 7.17 -> 6.86
  #      - 9.41 -> 9.18

# Mesure de la pression filtre Entrée ANA 1
  - platform: adc
    pin: GPIO36
    id: pression_filtre
    name: "${friendly_name}_Pression_filtre"
    unit_of_measurement: "Bars"
    update_interval: 60s
    attenuation: 12db
    filters:
      - calibrate_linear:
        - 0.60 -> 0.0
        - 0.87 -> 0.87
# moyenne sur 30 mn + affichage toutes les mn
      - sliding_window_moving_average:
          window_size: 30
          send_every: 1

# Entrée ANA2 GPIO34
  - platform: adc
    pin: GPIO34
    id: eana2
    name: "${friendly_name}_EANA2"
    unit_of_measurement: "Bars"
    update_interval: 60s
    attenuation: 12db

# Entrée ANA3 GPIO39
  - platform: adc
    pin: GPIO39
    id: eana3
    name: "${friendly_name}_EANA3"
    unit_of_measurement: "Bars"
    update_interval: 60s
    attenuation: 12db

# mémorise le temps d'injection calculé
  - platform: template
    name: "${friendly_name}_tps_injection_ph_moins"
    id: _tps_injection_ph_moins
    unit_of_measurement: "s"
    state_class: "measurement"  

# Déclaration des "Covers" 
# Volet piscine dans mon cas
cover:
  - platform: template
    name: "${friendly_name}_volet_piscine"
#    lambda: |-
#      if (id(volet_ferme).state) {
#        return COVER_OPEN;
#      } else {
#        return COVER_CLOSED;
#      }
    open_action:
      - script.execute: script_ouv_volet
    close_action:
      - script.execute: script_ferm_volet
    stop_action:
      - script.execute: script_stop_volet
    optimistic: true

# déclaration des "text_sensors"
text_sensor:
  # Affichage des heures de filtration dans Home Assistant
  - platform: template
    id: aff_duree
    name: "${friendly_name} affich_duree"
    icon: mdi:timer

# Déclaration des switches: cde des relais
switch:
  - platform: gpio
    name: "${friendly_name} cde_pompe_filtration"
    pin: GPIO32
    id: cde_ppe_filtration
    on_turn_on:
      then:
        - delay: !lambda "return id(g_tps_mesure_temp)*1000;" # Durée de fonctionnement de la pompe avant prise en compte de la température eau
        - logger.log:
            format: "Set tempo cde ppe"
            level: DEBUG
        - lambda: |-
            id(flag_tempo_ppe_filtre) = true;
    on_turn_off: 
      then:
        - logger.log:
            format: "Reset tempo cde ppe"
            level: DEBUG
        - lambda: |-
            id(flag_tempo_ppe_filtre) = false;
        - script.stop: _regul_ph
        - switch.turn_off: cde_ppe_ph_moins

  - platform: gpio
    name: "${friendly_name} cde_ppe_ph-"
    pin: GPIO33
    id: cde_ppe_ph_moins
    interlock: [cde_ppe_ph_plus]

  - platform: gpio
    name: "${friendly_name} cde_ppe_ph+"
    pin: GPIO25
    id: cde_ppe_ph_plus
    interlock: [cde_ppe_ph_moins]

  - platform: gpio
    name: "${friendly_name} cde_eclairage"
    pin: GPIO26
    id: cde_eclairage

  - platform: gpio
    name: "${friendly_name} cde_volet_ouverture"
    pin: GPIO27
    id: cde_volet_ouverture
    interlock: [cde_volet_fermeture]

  - platform: gpio
    name: "${friendly_name} cde_volet_fermeture"
    pin: GPIO14
    id: cde_volet_fermeture
    interlock: [cde_volet_ouverture]

  - platform: gpio
    name: "${friendly_name} cde_ev_eau"
    pin: GPIO12
    id: cde_ev_eau

  - platform: gpio
    name: "${friendly_name} relais8"
    pin: GPIO13
    id: relais8

  - platform: restart
    name: "${friendly_name} Restart"

# Gestion de l'afficheur 
display:
  - platform: lcd_pcf8574
    dimensions: 16x2
    address: 0x27
    update_interval: 5s
    lambda: |-
      it.printf(0,0,"Ph=%.2f",id(ph_ezo).state);
      it.printf(8,0,"P=%.3f",id(pression_filtre).state);
      it.printf(8,1,"T=%.1f",id(g_memoire_temp_eau));
#it.printf(15,1,"T=%.1s",id(mode_f).state);

# Déclenchement des scripts à intervalles réguliers
interval:
  - interval: 90s
    then:
      - script.execute: _regul_ph
  - interval: 5s
    then:      
      - script.execute: Fonctionnement_filtration
      - script.execute: calcul_niveau_eau
      - script.execute: _regul_eau
  - interval: 5s
    then: 
      - script.execute: memorisation_temperature_eau
    
# Déclaration des "Scripts"
script:

  # Si la pompe tourne depuis au moins 5min on raffraichit la memoire de la temperature eau qui est
  # prise en compte dans les scripts.
  # sinon on travaille avec la témpérature mémorisée avant l'arret précédent
  - id: memorisation_temperature_eau
    then:
      - if:
          condition:
            lambda: 'return id(flag_tempo_ppe_filtre) == true;'
          then:
            - lambda: |-
                id(g_memoire_temp_eau)=id(temp_eau).state;            
            - logger.log:
                format: "Flag=1 / Valeur Temp Dallas: %.2f / Valeur Mem Temp: %.2f"
                args: [ 'id(temp_eau).state','id(g_memoire_temp_eau)' ]
                level: DEBUG
          else:
            - lambda: |-
                id(g_memoire_temp_eau)=id(g_memoire_temp_eau);
            - logger.log:
                format: "Flag=0 / Valeur Temp Dallas: %.2f / Valeur Mem Temp: %.2f"
                args: [ 'id(temp_eau).state','id(g_memoire_temp_eau)' ]
                level: DEBUG


  # Calcul de la durée de la filtration en fonction du mode de fonctionnement selectionné
  - id: Fonctionnement_filtration
    then:
      # Mode Arret forcé
      - if:
          condition:
            - lambda: 'return id(_Mode_Fonctionnement_filtration).state == "At_f";'
          then:
            - switch.turn_off: cde_ppe_filtration
            - logger.log: 
                format: "arret_forcé_ppe_filtration"
                level: INFO
      # Mode Marche forcée
      - if:
          condition:
            - lambda: 'return id(_Mode_Fonctionnement_filtration).state == "Ma_f";'
          then:
            - switch.turn_on: cde_ppe_filtration
            - logger.log: 
                format: "Marche_forcée_ppe_filtration"
                level: INFO

      # Mode "Palier":
      # Si T°eau< Seuil Temp1 alors Durée = Tps paliers 1
      # Sinon
      # Si T°eau>= Seuil Temp1 et T°eau< Seuil Temp2 alors Durée = Tps paliers 2
      # Sinon
      # Si T°eau>= Seuil Temp2 et T°eau< Seuil Temp3 alors Durée = Tps paliers 3
      # Sinon
      # Si T°eau>= Seuil Temp3 et T°eau< Seuil Temp4 alors Durée = Tps paliers 4
      # Sinon
      # Durée = Tps paliers 5
      - if:
          condition:
            - lambda: 'return id(_Mode_Fonctionnement_filtration).state == "Palier";'
          then:
            - lambda: |-
                if (id(g_memoire_temp_eau)<id(g_temp_palier1)){
                  id(g_tps_filtration)=id(g_tps_palier1);
                } else {
                  if (id(g_memoire_temp_eau)>=id(g_temp_palier1) && (id(g_memoire_temp_eau)<id(g_temp_palier2))){
                    id(g_tps_filtration)=id(g_tps_palier2);
                  } else {
                    if (id(g_memoire_temp_eau)>=id(g_temp_palier2) && (id(g_memoire_temp_eau)<id(g_temp_palier3))){
                    id(g_tps_filtration)=id(g_tps_palier3);
                    } else {
                      if (id(g_memoire_temp_eau)>=id(g_temp_palier3) && (id(g_memoire_temp_eau)<id(g_temp_palier4))){
                      id(g_tps_filtration)=id(g_tps_palier4);
                      } else {
                        id(g_tps_filtration)=id(g_tps_palier5);
                      }
                    }
                  }
                }
                
                id(g_tps_filtration)=id(g_tps_filtration)*id(coeff_filtration).state/100;

            - logger.log:
                format: "Mode: Palier / Valeur Mem Temp: %.2f / Tps Filtrat: %2f"
                args: [ 'id(g_memoire_temp_eau)','id(g_tps_filtration)' ]
                level: DEBUG
            - script.execute: calcul_hdebut_hfin
      
      # Mode "Classique":
      # La durée de filtration en h est égale à la température de l'eau divisée par 2
      - if:
          condition:
            - lambda: 'return id(_Mode_Fonctionnement_filtration).state == "Classique";'
          then:
            - lambda: |-
                id(g_tps_filtration)=id(g_memoire_temp_eau)/2;
                id(g_tps_filtration)=min(id(g_temps_max_filtration),id(g_tps_filtration));
                id(g_tps_filtration)=max(id(g_temps_min_filtration),id(g_tps_filtration));
                id(g_tps_filtration)=id(g_tps_filtration)*id(coeff_filtration).state/100;
            - logger.log:
                format: "Mode Classique / Valeur Mem Temp: %.2f / Tps Filtrat: %2f"
                args: [ 'id(g_memoire_temp_eau)','id(g_tps_filtration)' ]
                level: DEBUG
            - script.execute: calcul_hdebut_hfin
      
      # Mode "Abacus"
      #
      - if:
          condition:
            - lambda: 'return id(_Mode_Fonctionnement_filtration).state == "Abaque";'
          then:
            - lambda: |-
                  id(g_tps_filtration)=id(g_abaque_a)*pow(id(g_memoire_temp_eau),3)+id(g_abaque_b)*pow(id(g_memoire_temp_eau),2)+id(g_abaque_c)*id(g_memoire_temp_eau)+id(g_abaque_d);
                  id(g_tps_filtration)=id(g_tps_filtration)*id(coeff_filtration).state/100;
                  id(g_tps_filtration)=min(id(g_temps_max_filtration),id(g_tps_filtration));
                  id(g_tps_filtration)=max(id(g_temps_min_filtration),id(g_tps_filtration));
            - logger.log:
                format: "Mode Abaque / Valeur Mem Temp: %.2f / Tps Filtrat: %2f"
                args: [ 'id(g_memoire_temp_eau)','id(g_tps_filtration)' ]
                level: DEBUG
            - script.execute: calcul_hdebut_hfin

      # Mode "Horaire"
      # Débuté à l'heure programmée pour un durée programmée
      # je m'en sers surtout l'hiver
      - if:
          condition:
            - lambda: 'return id(_Mode_Fonctionnement_filtration).state == "Horaire";'
          then:
            - logger.log:
                format: "Mode Abaque / Valeur Mem Temp: %.2f"
                args: [ 'id(g_memoire_temp_eau)' ]
                level: DEBUG

            - datetime.time.set:
                id: h_debut
                time: !lambda |-
                  return {second: 0, minute: id(debut_mode_horaire).minute, hour: id(debut_mode_horaire).hour};

            - datetime.time.set:
                id: h_fin
                time: !lambda |-
                  return {second: 0, minute: id(h_debut).minute+id(duree_mode_horaire).minute, hour: id(h_debut).hour+id(duree_mode_horaire).hour};

            - lambda: |-
                static String mes;
                mes= String(id(h_debut).hour)+":"+String(id(h_debut).minute)+"/"+String(id(h_fin).hour)+":"+String(id(h_fin).minute);
                id(aff_duree).publish_state(mes.c_str());

            - script.execute: calcul_ma_at_ppe_filtration

# Calcul l'heure de debut et fin de filtration en fonction la durée de filtration et l'heure pivot
# La variable: g_tps_filtration contient la durée en heure
  - id: calcul_hdebut_hfin
    mode: single
    then:
      #RAZ des secondes de l'heure pivot
      - datetime.time.set:
          id: heure_pivot
          time: !lambda |-
            return {second: 0,minute: id(heure_pivot).minute, hour: id(heure_pivot).hour};

      - logger.log:
          format: "HPivot %2d:%.2d:%2d"
          args: [ 'id(heure_pivot).hour', 'id(heure_pivot).minute', 'id(heure_pivot).second' ]
          level: DEBUG

      # Heure de debut = Heure pivot converti en minutes - temps filtration converti en minutes
      - lambda: |-
          static double dt=0;
          static double hp=0;
          
          hp = id(heure_pivot).hour*60+id(heure_pivot).minute;
          dt = id(heure_pivot).hour*60+id(heure_pivot).minute-((id(g_tps_filtration)/2)*60);

          id(g_hh)=int(dt/60);
          id(g_mm)=dt-id(g_hh)*60;

      - logger.log:
          format: "H debut Filtration %2d: %.2d"
          args: [ 'id(g_hh)', 'id(g_mm)' ]
          level: DEBUG

      - datetime.time.set:
          id: h_debut
          time: !lambda |-
            return {second: 0, minute: id(g_mm), hour: id(g_hh)};

      # Heure de fin = Heure pivot converti en minutes + temps filtration converti en minutes
      - lambda: |-
          static double dt=0;
          static double hp=0;
          
          hp = id(heure_pivot).hour*60+id(heure_pivot).minute;
          dt = id(heure_pivot).hour*60+id(heure_pivot).minute+((id(g_tps_filtration)/2)*60);

          id(g_hh)=int(dt/60);
          id(g_mm)=dt-id(g_hh)*60;

      - logger.log:
          format: "H debut Filtration %2d:%.2d"
          args: [ 'id(g_hh)', 'id(g_mm)' ]
          level: DEBUG

      - datetime.time.set:
          id: h_fin
          time: !lambda |-
            return {second: 0, minute: id(g_mm), hour: id(g_hh)};
      - lambda: |-
          static String mes;
          mes= String(id(h_debut).hour)+":"+String(id(h_debut).minute)+"/"+String(id(heure_pivot).hour)+":"+String(id(heure_pivot).minute)+"/"+String(id(h_fin).hour)+":"+String(id(h_fin).minute);
          id(aff_duree).publish_state(mes.c_str());

      - script.execute: calcul_ma_at_ppe_filtration

# Calcul la sortie de commande la pompe de filtration en fonction de l'heure actuelle, de l'heure de début et de l'heure de fin
  - id: calcul_ma_at_ppe_filtration
    mode: single
    then:
      - lambda: |-
          auto time = id(sntp_time).now();
      - logger.log:
          format: "H now: %.2d:%2d:%d"
          args: [ 'id(sntp_time).now().hour', 'id(sntp_time).now().minute', 'id(heure_pivot).second' ]
          level: DEBUG
      - logger.log:
          format: "HT: %.2d - HD:%2d - HF:%d"
          args: [ 'id(sntp_time).now().hour*60+id(sntp_time).now().minute', 'id(h_debut).hour*60+id(h_debut).minute', 'id(h_fin).hour*60+id(h_fin).minute' ]
          level: DEBUG
      - if:
          condition:
            time.has_time:
          then:
            - logger.log:
                format: "L'heure est initialisée et valide!"
                level: INFO
          else:
            - logger.log:
                format: "L'heure n'est pas initialisée et valide!"
                level: INFO
      - if:
          condition:
            - lambda: 'return (id(sntp_time).now().is_valid());'
            - lambda: 'return (id(sntp_time).now().hour*60+id(sntp_time).now().minute >= id(h_debut).hour*60+id(h_debut).minute && id(sntp_time).now().hour*60+id(sntp_time).now().minute < id(h_fin).hour*60+id(h_fin).minute);'
          then:
            - switch.turn_on: cde_ppe_filtration
          else:
            - switch.turn_off: cde_ppe_filtration 

# Regulation du pH
# Calcul du temps d'injection en fonction:
#   - de l'écart mesure-consigne
#   - du debit ppe pH
#   - de la concentration du pH moins
  - id: _regul_ph
    mode: single  
    then:
      - lambda: |-
          id(g_tps_injection_ph_moins)=(((id(ph_ezo).state-id(_ph_cible).state)/(id(_taux_concentration_ph_moins).state/100)/id(_debit_ppe_moins).state))*3600;
          id(_tps_injection_ph_moins).publish_state(id(g_tps_injection_ph_moins));
      
      - logger.log:
          format: "Log tps injection: %f"
          args: [ 'id(g_tps_injection_ph_moins)' ]
          level: INFO

      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_regul_ph).state == "Auto";'
              - lambda: 'return id(ph_ezo).state > id( _ph_cible).state;'
              - lambda: 'return id(ph_ezo).state > 0;'
              - switch.is_on: cde_ppe_filtration
          then:
            - switch.turn_on: cde_ppe_ph_moins
            - logger.log: 
                format: "Marche ppe Ph moins"
                level: INFO        
            - delay: !lambda "return id(g_tps_injection_ph_moins)*1000;"
            - switch.turn_off: cde_ppe_ph_moins
            - logger.log: 
                format: "Arret ppe Ph moins"
                level: INFO

      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_regul_ph).state == "Ma_f";'
              - switch.is_on: cde_ppe_filtration
          then:
            - switch.turn_on: cde_ppe_ph_moins
            - logger.log: 
                format: "Marche ppe Ph moins"
                level: INFO
      - if:
          condition:
            or:
              - lambda: 'return id(_Mode_Fonctionnement_regul_ph).state == "At_f";'
              - switch.is_off: cde_ppe_filtration
          then:
            - switch.turn_off: cde_ppe_ph_moins
            - logger.log: 
                format: "Arret ppe Ph moins"
                level: INFO

# Regulation du niveau eau piscine
  - id: _regul_eau
    mode: single  
    then:
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_regul_eau).state == "Auto";'
              - binary_sensor.is_off: niv_defaut
              - binary_sensor.is_off: volet_ferme
              - or:
                - binary_sensor.is_on: niv_bas
                - binary_sensor.is_on: niv_inter
          then:
            - logger.log: 
                format: "Ouverture vanne eau Mode Auto"
                level: INFO
            - switch.turn_on: cde_ev_eau
            - delay: 15min
            - logger.log: 
                format: "Fermeture vanne eau sur Timeout 15 min"
                level: WARN
            - switch.turn_off: cde_ev_eau
      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_regul_eau).state == "Auto";'
              - or:
                - binary_sensor.is_on: niv_haut
                - binary_sensor.is_on: niv_defaut
          then:
            - logger.log: 
                format: "Fermeture vanne eau Mode Auto"
                level: INFO
            - switch.turn_off: cde_ev_eau

      - if:
          condition:
            and:
              - lambda: 'return id(_Mode_Fonctionnement_regul_eau).state == "Ma_f";'
          then: 
            - logger.log: 
                format: "Ouverture vanne eau Mode Ma Forçé"
                level: INFO
            - switch.turn_on: cde_ev_eau

      - if:
          condition:
            or:
              - lambda: 'return id(_Mode_Fonctionnement_regul_eau).state == "At_f";'
          then:
            - logger.log: 
                format: "Fermeture vanne eau Mode At Forçé"
                level: INFO
            - switch.turn_off: cde_ev_eau

# Scripts Commande Volet
  - id: script_ouv_volet
    then:
      - switch.turn_off: cde_volet_fermeture
      - delay: 2s
      - switch.turn_on: cde_volet_ouverture
      - delay: 5s
      - switch.turn_off: cde_volet_ouverture
          
  - id: script_ferm_volet
    then:
      - switch.turn_off: cde_volet_ouverture
      - delay: 2s
      - switch.turn_on: cde_volet_fermeture
      - switch.turn_on: cde_eclairage
      - delay: 90s
      - switch.turn_off: cde_volet_fermeture
      - switch.turn_off: cde_eclairage
                    
  - id: script_stop_volet
    then:
      - switch.turn_off: cde_volet_ouverture
      - switch.turn_off: cde_volet_fermeture
      - delay: 2s
      - switch.turn_on: cde_volet_fermeture
      - delay: 2s
      - switch.turn_off: cde_volet_fermeture
      - switch.turn_off: cde_eclairage

# Calcul des niveaux d'eau en fonction des sondes de niveaux
# si niveau haut et niveau bas => niveau haut
  - id: calcul_niveau_eau
    then:
      - if: 
          condition:
            and:
              - binary_sensor.is_on: lsh
              - binary_sensor.is_on: lsl
          
          then:
            - binary_sensor.template.publish:
                id: niv_haut
                state: ON
          else:
            - binary_sensor.template.publish:
                id: niv_haut
                state: OFF
# si pas niveau haut et niveau bas => defaut intermédiaire
      - if: 
          condition:
            and:
              - binary_sensor.is_off: lsh
              - binary_sensor.is_on: lsl
          
          then:
            - binary_sensor.template.publish:
                id: niv_inter
                state: ON
          else:
            - binary_sensor.template.publish:
                id: niv_inter
                state: OFF     
# si pas niveau haut et pas niveau bas => niveau bas
      - if: 
          condition:
            and:
              - binary_sensor.is_off: lsh
              - binary_sensor.is_off: lsl
          
          then:
            - binary_sensor.template.publish:
                id: niv_bas
                state: ON
          else:
            - binary_sensor.template.publish:
                id: niv_bas
                state: OFF                
# si niveau haut et pas niveau bas => defaut niveau
      - if: 
          condition:
            and:
              - binary_sensor.is_on: lsh
              - binary_sensor.is_off: lsl
          
          then:
            - binary_sensor.template.publish:
                id: niv_defaut
                state: ON
          else:
            - binary_sensor.template.publish:
                id: niv_defaut
                state: OFF                                