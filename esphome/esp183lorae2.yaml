# Pour memoire:
#   - Conso au boot: ~ 105mA
#   - Conso sans WiFi: ~40 mA
#   - Cons en veille: 4.1 mA
substitutions:
  name_e1: esp183lorae2
  adress_ip: 192.168.0.183
  

esphome:
  name: ${name_e1}
  # Executer au reveil de l'ESP 
  on_boot:
    priority: 800
    then:
      - script.execute: maj_data

  # Executer à l'endormissement de l'ESP
  on_shutdown: 
    then:
      - switch.turn_off: led
      - sx127x.set_mode_sleep # On endort LoRa
        
esp32:
  board: esp32-c3-devkitm-1
  cpu_frequency: 160MHZ
  framework:
    type: esp-idf

# Enable logging
logger:
  hardware_uart: UART0
  level: VERBOSE

api:

ota:
  - platform: esphome


wifi:
  networks:
    - ssid: !secret wifi_esp
      password: !secret mdpwifi_esp
  fast_connect: true
  reboot_timeout: 2min
  output_power: 20dB
  power_save_mode: none
  enable_btm: true
  enable_rrm: true

  manual_ip:
    static_ip: ${adress_ip}
    gateway: 192.168.0.254
    subnet: 255.255.255.0
    dns1: !secret dns1
    dns2: !secret dns2

#web_server:
#  port: 80

spi:
  clk_pin: GPIO04
  mosi_pin: GPIO06
  miso_pin: GPIO01

sx127x:
  data_rate: 1Mhz
  dio0_pin: GPIO05
  cs_pin: GPIO07 
  rst_pin: GPIO03 
  pa_pin: BOOST
  pa_power: 8
  bandwidth: 125_0kHz
  crc_enable: true
  frequency: 433920000
  modulation: LORA
  rx_start: true
  sync_value: 0x12
  spreading_factor: 7
  preamble_size: 8
  coding_rate: CR_4_6
  #on_packet:
  #  then:
  #    - lambda: |-
  #        ESP_LOGD("lambda", "packet %s", format_hex(x).c_str());
  #        ESP_LOGD("lambda", "rssi %.2f", rssi);
  #        ESP_LOGD("lambda", "snr %.2f", snr);

packet_transport:
  platform: sx127x
  id: pt
  #update_interval: 15s
  encryption: !secret encryption_key
  rolling_code_enable: false
  providers:
    - name: ${name_e1}
      encryption: !secret encryption_key
  sensors: 
    - id: ${name_e1}_temperature
    - id: ${name_e1}_compteur

one_wire:
  - platform: gpio
    pin: GPIO09
    id: ow1

globals:
  - id: compteur
    type: int
    restore_value: yes
    initial_value: '0'

sensor:
  - platform: dallas_temp
    name: ${name_e1}_temperature
    id: ${name_e1}_temperature
    accuracy_decimals: 2
    update_interval: 60min

  - platform: template
    name: ${name_e1}_compteur
    id: ${name_e1}_compteur
    unit_of_measurement: "count"
    update_interval: never
    lambda: |-
      return id(compteur);

binary_sensor:
  - platform: gpio
    name: Sleep Ent
    pin: 
      number: GPIO0
      mode:
        input: true
        pullup: true
    id: sleep_ent
    internal: False
    filters:
      - invert:  

switch:
  - platform: gpio
    id: led
    name: led
    pin:
      number: GPIO20
      inverted: False
    restore_mode: ALWAYS_OFF

  - platform: restart
    name: "Restart"


# Mode "On endort l'ESP"
deep_sleep:
  id: sleep_xmin
  run_duration: 10s # Butée Max
  sleep_duration: 120s 

# Intervalle pour gérer l'envoi des mesures et deep sleep dynamique
interval:
  - interval: 10s
    then:
      - script.execute: maj_data

script:
  # Envoi LoRa en fonction du mode Nomal ou Sleep sélectionné par Jumper sur GPIO0
  - id: maj_data
    then:
     - delay: 1s # Le temps de lire le GPIO
     - if:
          condition:
            binary_sensor.is_off: sleep_ent
          # Mode Normal
          then:
            - switch.turn_on: led
            - delay: 200ms
            - switch.turn_off: led            
            - logger.log: "Mode actif: WiFi actif, envoi temp toutes les 10s"
            - wifi.enable # Active le WIFI
            - deep_sleep.prevent: sleep_xmin # Empeche la mise en veille
            - script.execute: lecture_capteur

          # Mode Sleep
          else: 
            - switch.turn_on: led
            - delay: 200ms
            - switch.turn_off: led
            - logger.log: "Mode sleep: WiFi OFF, envoi LoRa puis sommeil"
            - wifi.disable
            - script.execute: lecture_capteur
            - delay: 2s
            - deep_sleep.enter: sleep_xmin
  
  # Mise à jour des capteurs avant envoi par LoRa
  - id: lecture_capteur
    then: 
      # Force la lecture du capteur avant de publier
      - component.update: ${name_e1}_temperature
      - lambda: |-
          // Incrémente le compteur et le limite à 99
          id(compteur) = (id(compteur) + 1) % 100;
          id(${name_e1}_compteur).publish_state(id(compteur));
      - delay: 1s   # petit délai pour que la lecture se fasse
      - component.update: pt # Mise à Jour LoRa
      