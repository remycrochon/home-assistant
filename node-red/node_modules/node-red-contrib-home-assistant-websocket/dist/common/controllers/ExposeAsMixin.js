"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const homeAssistant_1 = require("../../homeAssistant");
const Events_1 = __importDefault(require("../events/Events"));
function ExposeAsMixin(Base) {
    var _ExposeAsController_instances, _ExposeAsController_numberOfOutputs_get, _ExposeAsController_onTriggered, _a;
    return _a = class ExposeAsController extends Base {
            constructor() {
                super(...arguments);
                _ExposeAsController_instances.add(this);
            }
            setExposeAsConfigNode(exposeAsConfigNode) {
                this.exposeAsConfigNode = exposeAsConfigNode;
                if (exposeAsConfigNode) {
                    this.exposeAsConfigEvents = new Events_1.default({
                        node: this.node,
                        emitter: exposeAsConfigNode,
                    });
                    this.exposeAsConfigEvents.addListener(homeAssistant_1.HaEvent.AutomationTriggered, __classPrivateFieldGet(this, _ExposeAsController_instances, "m", _ExposeAsController_onTriggered).bind(this));
                }
            }
            get isEnabled() {
                var _a, _b, _c;
                return (_c = (_b = (_a = this.exposeAsConfigNode) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.isEnabled()) !== null && _c !== void 0 ? _c : true;
            }
            getExposeAsConfigEvents() {
                return this.exposeAsConfigEvents;
            }
            enableExposeAs(enable = true) {
                var _a, _b;
                (_a = this.exposeAsConfigNode) === null || _a === void 0 ? void 0 : _a.integration.updateStateAndAttributes(enable, {});
                (_b = this.exposeAsConfigNode) === null || _b === void 0 ? void 0 : _b.state.setEnabled(enable);
            }
        },
        _ExposeAsController_instances = new WeakSet(),
        _ExposeAsController_numberOfOutputs_get = function _ExposeAsController_numberOfOutputs_get() {
            if ('wires' in this.node && Array.isArray(this.node.wires)) {
                return this.node.wires.length;
            }
            return 0;
        },
        _ExposeAsController_onTriggered = function _ExposeAsController_onTriggered(data) {
            if (!this.isEnabled)
                return;
            const outputCount = __classPrivateFieldGet(this, _ExposeAsController_instances, "a", _ExposeAsController_numberOfOutputs_get);
            // If there are no outputs, there is nothing to do
            if (outputCount === 0)
                return;
            // Remove any paths that are greater than the number of outputs
            const paths = data.output_path
                .split(',')
                .map((path) => Number(path))
                .filter((path) => path <= outputCount);
            // If there are no paths, there is nothing to do
            if (paths.length === 0)
                return;
            let payload;
            // If there is only one path and it is 0 or 1, return the payload as is
            if (paths.length === 1 && paths.includes(1)) {
                payload = data.message;
            }
            else if (paths.includes(0)) {
                // create an array the size of the number of outputs and fill it with the payload
                payload = new Array(outputCount).fill([data.message]);
            }
            else {
                // create an array and fill it with the message only if index exists in paths
                payload = new Array(outputCount)
                    .fill(0)
                    .map((_, index) => paths.includes(index + 1) ? data.message : null);
            }
            this.status.setSuccess('home-assistant.status.triggered');
            this.node.send(payload);
        },
        _a;
}
exports.default = ExposeAsMixin;
