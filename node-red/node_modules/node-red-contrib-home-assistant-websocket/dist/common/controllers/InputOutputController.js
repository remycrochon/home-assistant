"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _InputOutputController_instances, _InputOutputController_optionalInputs, _InputOutputController_preOnInput;
Object.defineProperty(exports, "__esModule", { value: true });
const inputErrorHandler_1 = require("../errors/inputErrorHandler");
const Events_1 = require("../events/Events");
const InputService_1 = __importDefault(require("../services/InputService"));
const OutputController_1 = __importDefault(require("./OutputController"));
class InputOutputController extends OutputController_1.default {
    constructor(params) {
        super(params);
        _InputOutputController_instances.add(this);
        _InputOutputController_optionalInputs.set(this, new Map());
        this.inputService = params.inputService;
        this.integration = params.integration;
        params.node.on(Events_1.NodeEvent.Input, __classPrivateFieldGet(this, _InputOutputController_instances, "m", _InputOutputController_preOnInput).bind(this));
    }
    addOptionalInput(key, schema, handler) {
        __classPrivateFieldGet(this, _InputOutputController_optionalInputs, "f").set(key, {
            schema,
            handler,
        });
    }
    removeOptionalInput(key) {
        __classPrivateFieldGet(this, _InputOutputController_optionalInputs, "f").delete(key);
    }
}
_InputOutputController_optionalInputs = new WeakMap(), _InputOutputController_instances = new WeakSet(), _InputOutputController_preOnInput = async function _InputOutputController_preOnInput(message, send, done) {
    var _a;
    // Run optional inputs
    if (__classPrivateFieldGet(this, _InputOutputController_optionalInputs, "f").size) {
        for (const [, { schema, handler }] of __classPrivateFieldGet(this, _InputOutputController_optionalInputs, "f")) {
            let validSchema = false;
            try {
                validSchema = InputService_1.default.validateSchema(schema, message);
            }
            catch (e) { } // silent fail
            if (validSchema) {
                try {
                    if (await handler(message, send)) {
                        done();
                        return;
                    }
                }
                catch (error) {
                    (0, inputErrorHandler_1.inputErrorHandler)(error, { done, status: this.status });
                }
            }
        }
    }
    const parsedMessage = this.inputService.parse(message);
    try {
        this.inputService.validate(parsedMessage);
        await ((_a = this.onInput) === null || _a === void 0 ? void 0 : _a.call(this, {
            parsedMessage,
            message,
            send,
            done,
        }));
    }
    catch (e) {
        (0, inputErrorHandler_1.inputErrorHandler)(e, { done, status: this.status });
    }
};
exports.default = InputOutputController;
