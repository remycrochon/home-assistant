"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BidirectionalIntegration_unsubscribe;
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../homeAssistant/index");
const helpers_1 = require("./helpers");
const Integration_1 = require("./Integration");
const UnidirectionalEntityIntegration_1 = __importDefault(require("./UnidirectionalEntityIntegration"));
class BidirectionalIntegration extends UnidirectionalEntityIntegration_1.default {
    constructor() {
        super(...arguments);
        _BidirectionalIntegration_unsubscribe.set(this, void 0);
    }
    async register() {
        if (!this.isIntegrationLoaded || this.isRegistered) {
            return;
        }
        const haConfig = (0, helpers_1.createHaConfig)(this.entityConfigNode.config.haConfig);
        try {
            const payload = this.getDiscoveryPayload({
                config: haConfig,
                state: this.state,
            });
            this.entityConfigNode.debug(`Registering ${this.entityConfigNode.config.entityType} node with Home Assistant`);
            __classPrivateFieldSet(this, _BidirectionalIntegration_unsubscribe, await this.homeAssistant.websocket.subscribeMessage(this.onHaEventMessage.bind(this), payload, { resubscribe: false }), "f");
        }
        catch (err) {
            this.status.forEach((status) => status.setFailed('home-assistant.status.error_registering'));
            const message = err instanceof Error ? err.message : err;
            this.entityConfigNode.error(`Error registering entity. Error Message: ${message}`);
            return;
        }
        this.saveHaConfigToContext(haConfig);
        this.status.forEach((status) => status === null || status === void 0 ? void 0 : status.setSuccess('home-assistant.status.registered'));
        this.registered = true;
    }
    async unregister() {
        var _a;
        await ((_a = __classPrivateFieldGet(this, _BidirectionalIntegration_unsubscribe, "f")) === null || _a === void 0 ? void 0 : _a.call(this));
        __classPrivateFieldSet(this, _BidirectionalIntegration_unsubscribe, undefined, "f");
        await super.unregister();
    }
    async updateHomeAssistant(state) {
        if (!this.isIntegrationLoaded)
            return;
        const message = {
            type: Integration_1.MessageType.Entity,
            server_id: this.entityConfigNode.config.server,
            node_id: this.entityConfigNode.id,
            state: state !== null && state !== void 0 ? state : this.state.isEnabled(),
        };
        try {
            await this.homeAssistant.websocket.send(message);
        }
        catch (err) {
            this.entityConfigNode.error(`Error updating entity. Error Message: ${err}`);
        }
    }
    onHaEventMessage(evt) {
        var _a;
        (_a = evt.type) !== null && _a !== void 0 ? _a : (evt.type = index_1.HaEvent.StateChanged); // no type prior to 0.20.0
        switch (evt.type) {
            case index_1.HaEvent.AutomationTriggered:
                this.entityConfigNode.emit(index_1.HaEvent.AutomationTriggered, evt.data);
                break;
            case index_1.HaEvent.StateChanged: {
                const previousState = this.state.isEnabled();
                this.state.setEnabled(evt.state);
                this.entityConfigNode.emit(index_1.HaEvent.StateChanged, {
                    state: evt.state,
                    changed: evt.state !== previousState,
                });
                this.updateHomeAssistant();
                break;
            }
        }
    }
    getStateData(state) {
        if (!state) {
            return {};
        }
        const data = {
            state: state.isEnabled(),
        };
        return data;
    }
}
_BidirectionalIntegration_unsubscribe = new WeakMap();
exports.default = BidirectionalIntegration;
