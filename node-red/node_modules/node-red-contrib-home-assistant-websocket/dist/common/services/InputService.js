"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _InputService_instances, _InputService_inputs, _InputService_nodeConfig, _InputService_schema, _InputService_allowInputOverrides, _InputService_parsedMessageToSchemaObject;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSource = void 0;
const selectn_1 = __importDefault(require("selectn"));
var DataSource;
(function (DataSource) {
    DataSource["Config"] = "config";
    DataSource["Default"] = "default";
    DataSource["Message"] = "message";
    DataSource["Missing"] = "missing";
})(DataSource || (exports.DataSource = DataSource = {}));
class InputService {
    constructor({ inputs, nodeConfig, schema, }) {
        _InputService_instances.add(this);
        _InputService_inputs.set(this, void 0);
        _InputService_nodeConfig.set(this, void 0);
        _InputService_schema.set(this, void 0);
        _InputService_allowInputOverrides.set(this, true);
        __classPrivateFieldSet(this, _InputService_inputs, inputs !== null && inputs !== void 0 ? inputs : {}, "f");
        __classPrivateFieldSet(this, _InputService_nodeConfig, nodeConfig, "f");
        __classPrivateFieldSet(this, _InputService_schema, schema, "f");
    }
    // TODO: Add logic to block input if inputOptions.block is true
    parse(msg) {
        const parsedResult = {};
        for (const [fieldKey, fieldConfig] of Object.entries(__classPrivateFieldGet(this, _InputService_inputs, "f"))) {
            let result = {
                key: fieldKey,
                value: undefined,
                source: DataSource.Missing,
            };
            if (__classPrivateFieldGet(this, _InputService_allowInputOverrides, "f")) {
                // Find messageProp value if it's a string or Array
                // When it's an array lowest valid index takes precedent
                const props = Array.isArray(fieldConfig.messageProp)
                    ? fieldConfig.messageProp
                    : [fieldConfig.messageProp];
                const messageProp = props.reduce((val, cur) => val !== null && val !== void 0 ? val : (0, selectn_1.default)(cur, msg), undefined);
                result = {
                    key: fieldKey,
                    value: messageProp,
                    source: DataSource.Message,
                };
            }
            // If message missing value and node has config that can be used instead
            if (result.value === undefined && fieldConfig.configProp) {
                result.value = (0, selectn_1.default)(fieldConfig.configProp, __classPrivateFieldGet(this, _InputService_nodeConfig, "f"));
                result.source = DataSource.Config;
            }
            if (result.value === undefined &&
                fieldConfig.default !== undefined) {
                result.value = fieldConfig.default;
                result.source = DataSource.Default;
            }
            // If value not found in both config and message
            if (result.value === undefined) {
                result.source = DataSource.Missing;
            }
            // Assign result to config key value
            parsedResult[fieldKey] = result;
        }
        return parsedResult;
    }
    validate(parsedMessage) {
        if (!__classPrivateFieldGet(this, _InputService_schema, "f"))
            return true;
        const schemaObject = __classPrivateFieldGet(this, _InputService_instances, "m", _InputService_parsedMessageToSchemaObject).call(this, parsedMessage);
        return InputService.validateSchema(__classPrivateFieldGet(this, _InputService_schema, "f"), schemaObject);
    }
    static validateSchema(schema, obj) {
        const { error } = schema.validate(obj);
        if (error)
            throw error;
        return true;
    }
    disableInputOverrides() {
        __classPrivateFieldSet(this, _InputService_allowInputOverrides, false, "f");
    }
    enableInputOverrides() {
        __classPrivateFieldSet(this, _InputService_allowInputOverrides, true, "f");
    }
}
_InputService_inputs = new WeakMap(), _InputService_nodeConfig = new WeakMap(), _InputService_schema = new WeakMap(), _InputService_allowInputOverrides = new WeakMap(), _InputService_instances = new WeakSet(), _InputService_parsedMessageToSchemaObject = function _InputService_parsedMessageToSchemaObject(parsedMessage) {
    const schemaObject = {};
    for (const [key, value] of Object.entries(parsedMessage)) {
        schemaObject[key] = value.value;
    }
    return schemaObject;
};
exports.default = InputService;
