"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsMustache = exports.checkValidServerConfig = exports.isNodeRedEnvVar = exports.validEntityId = exports.removeEventListeners = exports.addEventListeners = exports.getEntitiesFromJsonata = exports.parseTime = exports.isValidDate = exports.getTimeInMilliseconds = exports.getWaitStatusText = exports.toCamelCase = exports.shouldIncludeEvent = exports.shouldInclude = void 0;
const globals_1 = require("../globals");
function shouldInclude(targetString, includeRegex, excludeRegex) {
    if (!targetString || (!includeRegex && !excludeRegex)) {
        return true;
    }
    // If include regex isn't passed then include everything since test will be skipped
    // otherwise default to false and set in regex test
    let shouldIncludeTest = !includeRegex;
    let shouldExcludeTest = false;
    if (includeRegex && includeRegex.test(targetString)) {
        shouldIncludeTest = true;
    }
    if (excludeRegex && excludeRegex.test(targetString)) {
        shouldExcludeTest = true;
    }
    return shouldIncludeTest && !shouldExcludeTest;
}
exports.shouldInclude = shouldInclude;
function shouldIncludeEvent(eventId, filter, filterType) {
    if (!filter)
        return true;
    if (typeof filter === 'string') {
        if (filterType === 'substring') {
            return eventId.includes(filter);
        }
        if (filterType === 'regex') {
            return new RegExp(filter).test(eventId);
        }
    }
    if (Array.isArray(filter)) {
        return filter.includes(eventId);
    }
    return eventId === filter;
}
exports.shouldIncludeEvent = shouldIncludeEvent;
function toCamelCase(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, (match, index) => {
        if (+match === 0)
            return '';
        return index === 0 ? match.toLowerCase() : match.toUpperCase();
    });
}
exports.toCamelCase = toCamelCase;
function getWaitStatusText(timeout, timeoutUnits) {
    const timeoutMs = getTimeInMilliseconds(timeout, timeoutUnits);
    switch (timeoutUnits) {
        case 'milliseconds':
            return `waiting for ${timeout} milliseconds`;
        case 'hours':
        case 'days':
            return `waiting until ${timeoutStatus(timeoutMs)}`;
        case 'minutes':
        default:
            return `waiting for ${timeout} ${timeoutUnits}: ${timeoutStatus(timeoutMs)}`;
    }
}
exports.getWaitStatusText = getWaitStatusText;
function getTimeInMilliseconds(value, valueUnits) {
    switch (valueUnits) {
        case 'milliseconds':
            return value;
        case 'minutes':
            return value * 60000;
        case 'hours':
            return value * 3.6e6;
        case 'days':
            return value * 8.64e7;
        default:
            return value * 1000;
    }
}
exports.getTimeInMilliseconds = getTimeInMilliseconds;
function timeoutStatus(milliseconds = 0) {
    const timeout = Date.now() + milliseconds;
    const timeoutStr = new Date(timeout).toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        hour12: false,
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
    });
    return timeoutStr;
}
function isValidDate(val) {
    const d = new Date(val);
    return d instanceof Date && !isNaN(d.getTime());
}
exports.isValidDate = isValidDate;
function parseTime(time) {
    const regex = /^(0?\d|1\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/;
    const matches = time.match(regex);
    if (!matches)
        return;
    const [, hour, minutes, seconds = 0] = matches;
    return {
        hour: Number(hour),
        minutes: Number(minutes),
        seconds: Number(seconds),
    };
}
exports.parseTime = parseTime;
function getEntitiesFromJsonata(jsonata) {
    const regex = /\$entities\("([a-z_]+\.[a-z0-9_]+)"\)/g;
    const matches = jsonata.matchAll(regex);
    return new Set(Array.from(matches, (m) => m[1]));
}
exports.getEntitiesFromJsonata = getEntitiesFromJsonata;
function addEventListeners(eventListeners, emitter) {
    if (!emitter)
        return;
    eventListeners.forEach(([event, callback]) => {
        emitter.on(event, callback);
    });
}
exports.addEventListeners = addEventListeners;
function removeEventListeners(eventListeners, emitter) {
    if (!emitter)
        return;
    eventListeners.forEach(([event, callback]) => {
        emitter.off(event, callback);
    });
}
exports.removeEventListeners = removeEventListeners;
// https://github.com/home-assistant/core/blob/77ee72cbb9fed55779b0ee58443c3f41e5b35f5a/homeassistant/core.py#L125
function validEntityId(entityId) {
    return /^(?!.+__)(?!_)[\da-z_]+(?<!_)\.(?!_)[\da-z_]+(?<!_)$/.test(entityId);
}
exports.validEntityId = validEntityId;
function isNodeRedEnvVar(envVar) {
    // Check for ${env-var}
    return /^\$\{[a-zA-Z_][a-zA-Z0-9_]*\}$/.test(envVar);
}
exports.isNodeRedEnvVar = isNodeRedEnvVar;
function checkValidServerConfig(node, serverNodeId) {
    const serverConfigNode = globals_1.RED.nodes.getNode(serverNodeId !== null && serverNodeId !== void 0 ? serverNodeId : '');
    if (!serverConfigNode) {
        node.status({
            fill: 'red',
            shape: 'dot',
            text: globals_1.RED._('home-assistant.status.error'),
        });
        throw new Error('Server config node not found');
    }
    return true;
}
exports.checkValidServerConfig = checkValidServerConfig;
function containsMustache(str) {
    const regex = /{{(?:(?!}}).+)}}/g;
    return regex.test(str);
}
exports.containsMustache = containsMustache;
