"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Http_client;
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const debug_1 = __importDefault(require("debug"));
const https_1 = __importDefault(require("https"));
const utils_1 = require("../helpers/utils");
const debug = (0, debug_1.default)('home-assistant:http');
class Http {
    constructor(config) {
        _Http_client.set(this, void 0);
        const apiOpts = {
            baseURL: `${config.host}/api`,
            headers: { Authorization: `Bearer ${config.access_token}` },
        };
        if (!config.rejectUnauthorizedCerts) {
            apiOpts.httpsAgent = new https_1.default.Agent({
                rejectUnauthorized: false,
            });
        }
        __classPrivateFieldSet(this, _Http_client, axios_1.default.create(apiOpts), "f");
    }
    async getHistory(timestamp, filterEntityId, endTimestamp, { include, exclude, flatten, } = {}) {
        let path = 'history/period';
        if (timestamp) {
            path = `${path}/${timestamp}`;
        }
        // eslint-disable-next-line camelcase
        const params = {};
        if (filterEntityId) {
            params.filter_entity_id = filterEntityId;
        }
        if (endTimestamp) {
            params.end_time = endTimestamp;
        }
        // History returns an array for each entity_id and that array contains objects for each history item
        const results = await this.get(path, params);
        // Filter out results by regex, include/exclude should already be an instance of RegEx
        if (include || exclude) {
            return results.reduce((acc, entityArr) => {
                var _a, _b;
                const entityId = (_b = (_a = entityArr[0]) === null || _a === void 0 ? void 0 : _a.entity_id) !== null && _b !== void 0 ? _b : null;
                if (entityId && (0, utils_1.shouldInclude)(entityId, include, exclude)) {
                    acc.push(entityArr);
                }
                return acc;
            }, []);
        }
        // Instead of returning the data from home assistant ( array for each entity_id ) return one flattened array
        // of one item per history entry
        if (flatten) {
            return results
                .reduce((acc, entityArr) => {
                return [...acc, ...entityArr];
            }, [])
                .sort((a, b) => {
                if (a.last_updated < b.last_updated) {
                    return -1;
                }
                if (a.last_updated > b.last_updated) {
                    return 1;
                }
                return 0;
            });
        }
        return results;
    }
    fireEvent(event, data) {
        return this.post(`events/${event}`, data);
    }
    renderTemplate(templateString) {
        return this.post('template', { template: templateString }, 'text');
    }
    async post(path, data = {}, responseType = 'json') {
        var _a;
        debug(`HTTP POST: ${__classPrivateFieldGet(this, _Http_client, "f").defaults.baseURL}/${path}`);
        __classPrivateFieldGet(this, _Http_client, "f").defaults.responseType = responseType;
        const response = await __classPrivateFieldGet(this, _Http_client, "f").post(path, data).catch((err) => {
            debug(`POST: request error: ${err.toString()}`);
            throw err;
        });
        return responseType === 'json'
            ? (_a = response.data) !== null && _a !== void 0 ? _a : ''
            : response.data;
    }
    async get(path, params = {}, responseType = 'json') {
        var _a;
        debug(`HTTP GET: ${__classPrivateFieldGet(this, _Http_client, "f").defaults.baseURL}/${path}`);
        __classPrivateFieldGet(this, _Http_client, "f").defaults.responseType = responseType;
        const response = await __classPrivateFieldGet(this, _Http_client, "f")
            .request({ url: path, params })
            .catch((err) => {
            debug(`GET: request error: ${err.toString()}`);
            throw err;
        });
        return responseType === 'json'
            ? (_a = response.data) !== null && _a !== void 0 ? _a : ''
            : response.data;
    }
}
_Http_client = new WeakMap();
exports.default = Http;
