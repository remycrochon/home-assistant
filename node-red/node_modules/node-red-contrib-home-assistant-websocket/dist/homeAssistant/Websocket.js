"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Websocket_instances, _Websocket_config, _Websocket_eventBus, _Websocket_servicesLoaded, _Websocket_statesLoaded, _Websocket_stopHeartbeat, _Websocket_subscribedEvents, _Websocket_unsubCallback, _Websocket_emitEvent, _Websocket_checkUserType, _Websocket_clientEvents, _Websocket_subscribeEntityRegistry, _Websocket_haEvents, _Websocket_onHomeAssistantRunning, _Websocket_integrationEvent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientEvent = exports.ClientState = void 0;
const debug_1 = __importDefault(require("debug"));
const home_assistant_js_websocket_1 = require("home-assistant-js-websocket");
const lodash_1 = require("lodash");
const const_1 = require("../const");
const globals_1 = require("../globals");
const collections_1 = require("./collections");
const createSocket_1 = __importStar(require("./createSocket"));
const heartbeat_1 = require("./heartbeat");
const debug = (0, debug_1.default)('home-assistant:ws');
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Connecting"] = 0] = "Connecting";
    ClientState[ClientState["Connected"] = 1] = "Connected";
    ClientState[ClientState["Disconnected"] = 2] = "Disconnected";
    ClientState[ClientState["Error"] = 3] = "Error";
    ClientState[ClientState["Running"] = 4] = "Running";
})(ClientState || (exports.ClientState = ClientState = {}));
var ClientEvent;
(function (ClientEvent) {
    ClientEvent["Close"] = "ha_client:close";
    ClientEvent["Connected"] = "ha_client:connected";
    ClientEvent["Connecting"] = "ha_client:connecting";
    ClientEvent["Error"] = "ha_client:error";
    ClientEvent["Integration"] = "integration";
    ClientEvent["Open"] = "ha_client:open";
    ClientEvent["Ready"] = "ha_client:ready";
    ClientEvent["Running"] = "ha_client:running";
    ClientEvent["ServicesLoaded"] = "ha_client:services_loaded";
    ClientEvent["StatesLoaded"] = "ha_client:states_loaded";
})(ClientEvent || (exports.ClientEvent = ClientEvent = {}));
class Websocket {
    constructor(config, eventBus) {
        _Websocket_instances.add(this);
        _Websocket_config.set(this, void 0);
        _Websocket_eventBus.set(this, void 0);
        _Websocket_servicesLoaded.set(this, false);
        _Websocket_statesLoaded.set(this, false);
        _Websocket_stopHeartbeat.set(this, void 0);
        _Websocket_subscribedEvents.set(this, new Set());
        _Websocket_unsubCallback.set(this, {});
        this.areas = [];
        this.devices = [];
        this.entities = [];
        this.connectionState = const_1.STATE_DISCONNECTED;
        this.integrationVersion = const_1.NO_VERSION;
        this.isHomeAssistantRunning = false;
        this.states = {};
        this.services = {};
        this.tags = null;
        __classPrivateFieldSet(this, _Websocket_config, config, "f");
        __classPrivateFieldSet(this, _Websocket_eventBus, eventBus, "f");
        __classPrivateFieldGet(this, _Websocket_eventBus, "f").on('ha_client:connecting', this.onClientConnecting.bind(this));
        this.onStatesLoadedAndRunning('initial_connection_ready');
    }
    get isConnected() {
        return this.connectionState === const_1.STATE_CONNECTED;
    }
    async connect() {
        // Convert from http:// -> ws://, https:// -> wss://
        const url = `ws${__classPrivateFieldGet(this, _Websocket_config, "f").host.substring(4)}/api/websocket`;
        const auth = {
            type: 'auth',
            access_token: __classPrivateFieldGet(this, _Websocket_config, "f").access_token,
        };
        this.client = await (0, home_assistant_js_websocket_1.createConnection)({
            createSocket: () => (0, createSocket_1.default)({
                auth,
                connectionDelay: __classPrivateFieldGet(this, _Websocket_config, "f").connectionDelay,
                eventBus: __classPrivateFieldGet(this, _Websocket_eventBus, "f"),
                rejectUnauthorizedCerts: __classPrivateFieldGet(this, _Websocket_config, "f").rejectUnauthorizedCerts,
                url,
            }),
        }).catch((e) => {
            this.connectionState = const_1.STATE_ERROR;
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:error');
            // Handle connection errors
            let message;
            switch (e) {
                case home_assistant_js_websocket_1.ERR_CANNOT_CONNECT:
                    message = globals_1.RED._('home-assistant.error.cannot-connect');
                    break;
                case home_assistant_js_websocket_1.ERR_INVALID_AUTH:
                    message = globals_1.RED._('home-assistant.error.invalid_auth');
                    break;
                case home_assistant_js_websocket_1.ERR_CONNECTION_LOST:
                    message = globals_1.RED._('home-assistant.error.connection_lost');
                    break;
                case home_assistant_js_websocket_1.ERR_HASS_HOST_REQUIRED:
                    message = globals_1.RED._('home-assistant.error.hass_host_required');
                    break;
                case home_assistant_js_websocket_1.ERR_INVALID_HTTPS_TO_HTTP:
                    message = 'ERR_INVALID_HTTPS_TO_HTTP';
                    break;
            }
            throw message ? new Error(message) : e;
        });
        // Check if user has admin privileges
        await __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_checkUserType).call(this);
        this.onClientOpen();
        // emit connected for only the first connection to the server
        // so we can setup certain things only once like registerEvents
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:connected');
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_clientEvents).call(this);
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_haEvents).call(this);
    }
    getUser() {
        return (0, home_assistant_js_websocket_1.getUser)(this.client);
    }
    async subscribeEvents(events) {
        const currentEvents = new Set(Object.values(events));
        // If events contains '__ALL__' register all events and skip individual ones
        if (currentEvents.has('__ALL__')) {
            if (__classPrivateFieldGet(this, _Websocket_subscribedEvents, "f").has('__ALL__')) {
                // Nothing to do
                return;
            }
            __classPrivateFieldGet(this, _Websocket_subscribedEvents, "f").forEach((e) => {
                if (e !== '__ALL__') {
                    __classPrivateFieldGet(this, _Websocket_unsubCallback, "f")[e]();
                    delete __classPrivateFieldGet(this, _Websocket_unsubCallback, "f")[e];
                    __classPrivateFieldGet(this, _Websocket_subscribedEvents, "f").delete(e);
                }
            });
            // subscribe to all event and save unsubscribe callback
            __classPrivateFieldGet(this, _Websocket_unsubCallback, "f").__ALL__ =
                await this.client.subscribeEvents((ent) => this.onClientEvents(ent));
            __classPrivateFieldGet(this, _Websocket_subscribedEvents, "f").add('__ALL__');
            return;
        }
        // Always need the state_changed event
        currentEvents.add(const_1.HA_EVENT_STATE_CHANGED);
        currentEvents.add(const_1.HA_EVENT_TAG_SCANNED);
        const add = new Set([...currentEvents].filter((x) => !__classPrivateFieldGet(this, _Websocket_subscribedEvents, "f").has(x)));
        const remove = new Set([...__classPrivateFieldGet(this, _Websocket_subscribedEvents, "f")].filter((x) => !currentEvents.has(x)));
        // Create new subscription list
        __classPrivateFieldSet(this, _Websocket_subscribedEvents, new Set([
            ...[...currentEvents].filter((x) => __classPrivateFieldGet(this, _Websocket_subscribedEvents, "f").has(x)),
            ...add,
        ]), "f");
        // Remove unused subscriptions
        remove.forEach((e) => {
            __classPrivateFieldGet(this, _Websocket_unsubCallback, "f")[e]();
            delete __classPrivateFieldGet(this, _Websocket_unsubCallback, "f")[e];
        });
        // Subscribe to each event type and save each unsubscribe callback
        for (const type of add) {
            __classPrivateFieldGet(this, _Websocket_unsubCallback, "f")[type] =
                await this.client.subscribeEvents((ent) => this.onClientEvents(ent), type);
        }
    }
    subscribeMessage(callback, subscribeMessage, options) {
        return this.client.subscribeMessage(callback, subscribeMessage, options);
    }
    onClientStates(entities) {
        if (!entities || Object.keys(entities).length === 0) {
            return;
        }
        this.states = entities;
        if (!__classPrivateFieldGet(this, _Websocket_statesLoaded, "f")) {
            __classPrivateFieldSet(this, _Websocket_statesLoaded, true, "f");
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:states_loaded', this.states);
        }
    }
    onClientServices(services) {
        if (!services || Object.keys(services).length === 0) {
            return;
        }
        this.services = services;
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.HA_EVENT_SERVICES_UPDATED, this.services);
        if (!__classPrivateFieldGet(this, _Websocket_servicesLoaded, "f")) {
            __classPrivateFieldSet(this, _Websocket_servicesLoaded, true, "f");
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:services_loaded');
        }
    }
    onStatesLoadedAndRunning(event = 'ready') {
        const statesLoaded = new Promise((resolve) => {
            __classPrivateFieldGet(this, _Websocket_eventBus, "f").once('ha_client:states_loaded', resolve);
        });
        const homeAssinstantRunning = new Promise((resolve) => {
            __classPrivateFieldGet(this, _Websocket_eventBus, "f").once('ha_client:running', resolve);
        });
        Promise.all([statesLoaded, homeAssinstantRunning]).then(([states]) => {
            __classPrivateFieldGet(this, _Websocket_eventBus, "f").emit(`ha_client:${event}`, states);
        });
    }
    onClientEvents(hassEvent) {
        var _a, _b;
        if (!hassEvent || !hassEvent.data) {
            return;
        }
        const eventType = hassEvent.event_type;
        const entityId = (_a = hassEvent === null || hassEvent === void 0 ? void 0 : hassEvent.data) === null || _a === void 0 ? void 0 : _a.entity_id;
        const event = {
            event_type: eventType,
            entity_id: entityId,
            event: hassEvent.data,
            origin: hassEvent.origin,
            time_fired: hassEvent.time_fired,
            context: hassEvent.context,
        };
        if (eventType === const_1.HA_EVENT_STATE_CHANGED) {
            const state = (_b = event === null || event === void 0 ? void 0 : event.event) === null || _b === void 0 ? void 0 : _b.new_state;
            // Validate a minimum state_changed event
            if (state && entityId) {
                this.states[entityId] = state;
            }
            else {
                debug(`Not processing ${const_1.HA_EVENT_STATE_CHANGED} event: ${JSON.stringify(event)}`);
                return;
            }
        }
        // Emit on the event type channel
        if (eventType) {
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, `${const_1.HA_EVENTS}:${eventType}`, event);
            // Most specific emit for event_type and entity_id
            if (entityId) {
                __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, `${const_1.HA_EVENTS}:${eventType}:${entityId}`, event);
            }
        }
        // Emit on all channel
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, `${const_1.HA_EVENTS}:all`, event);
    }
    async onClientConfigUpdate(config) {
        if (config.components.includes('nodered') &&
            this.integrationVersion === const_1.NO_VERSION) {
            try {
                const version = await this.getIntegrationVersion();
                this.createIntegrationEvent(const_1.INTEGRATION_LOADED, version);
            }
            catch (e) { }
        }
        if (!this.tags && config.components.includes('tag')) {
            await this.updateTagList();
        }
        // Prior to HA 0.111.0 state didn't exist
        if (config.state === undefined || config.state === 'RUNNING') {
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_onHomeAssistantRunning).call(this);
        }
    }
    async updateTagList() {
        var _a;
        try {
            this.tags = await this.send({
                type: 'tag/list',
            });
        }
        catch (e) {
            debug(`Error fetching tag list: ${e}`);
        }
        return (_a = this.tags) !== null && _a !== void 0 ? _a : [];
    }
    getIntegrationVersion() {
        return this.send({
            type: 'nodered/version',
        });
    }
    createIntegrationEvent(type, version) {
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_integrationEvent).call(this, {
            data: { type, version },
        });
    }
    onClientOpen() {
        this.onStatesLoadedAndRunning();
        this.integrationVersion = const_1.NO_VERSION;
        this.isHomeAssistantRunning = false;
        this.connectionState = const_1.STATE_CONNECTED;
        if (__classPrivateFieldGet(this, _Websocket_config, "f").heartbeatInterval) {
            __classPrivateFieldSet(this, _Websocket_stopHeartbeat, (0, heartbeat_1.startHeartbeat)(this.client, __classPrivateFieldGet(this, _Websocket_config, "f").heartbeatInterval, __classPrivateFieldGet(this, _Websocket_config, "f").host), "f");
        }
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:open');
    }
    onClientClose() {
        debug('events connection closed, cleaning up connection');
        this.resetClient();
    }
    onClientError(data) {
        debug('events connection error, cleaning up connection');
        debug(data);
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:error', data);
        this.resetClient();
    }
    onClientConnecting() {
        this.connectionState = const_1.STATE_CONNECTING;
    }
    close() {
        var _a;
        if (typeof __classPrivateFieldGet(this, _Websocket_stopHeartbeat, "f") === 'function')
            __classPrivateFieldGet(this, _Websocket_stopHeartbeat, "f").call(this);
        (_a = this === null || this === void 0 ? void 0 : this.client) === null || _a === void 0 ? void 0 : _a.close();
    }
    resetClient() {
        this.integrationVersion = const_1.NO_VERSION;
        this.isHomeAssistantRunning = false;
        __classPrivateFieldSet(this, _Websocket_servicesLoaded, false, "f");
        __classPrivateFieldSet(this, _Websocket_statesLoaded, false, "f");
        this.connectionState = const_1.STATE_DISCONNECTED;
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:close');
    }
    getAreas() {
        return this.areas;
    }
    getDevices() {
        return this.devices;
    }
    async getDeviceActions(deviceId) {
        if (!this.isConnected || !deviceId)
            return [];
        return this.send({
            type: 'device_automation/action/list',
            device_id: deviceId,
        });
    }
    async getDeviceActionCapabilities(action) {
        if (!this.isConnected || !action)
            return [];
        const results = await this.send({
            type: 'device_automation/action/capabilities',
            action,
        });
        return results.extra_fields;
    }
    async getDeviceTriggers(deviceId) {
        if (!this.isConnected || !deviceId)
            return [];
        return this.send({
            type: 'device_automation/trigger/list',
            device_id: deviceId,
        });
    }
    async getDeviceTriggerCapabilities(trigger) {
        if (!this.isConnected || !trigger)
            return [];
        const results = await this.send({
            type: 'device_automation/trigger/capabilities',
            trigger,
        });
        return results.extra_fields;
    }
    getEntities() {
        return this.entities;
    }
    getStates(entityId) {
        if (typeof entityId === 'string') {
            return this.states[entityId]
                ? (0, lodash_1.cloneDeep)(this.states[entityId])
                : null;
        }
        return (0, lodash_1.cloneDeep)(this.states);
    }
    getServices() {
        return (0, lodash_1.cloneDeep)(this.services);
    }
    async getTranslations(category, language) {
        if (!this.isConnected || !category)
            return [];
        const results = await this.send({
            type: 'frontend/get_translations',
            language,
            category,
        });
        return results.resources;
    }
    callService(domain, service, data, target) {
        debug(`Call-Service: ${domain}.${service} ${JSON.stringify(data)}`);
        return (0, home_assistant_js_websocket_1.callService)(this.client, domain, service, data, target);
    }
    send(data) {
        var _a;
        if (!this.isConnected) {
            throw new Error('Client is not connected');
        }
        debug(`Send: ${JSON.stringify(data)}`);
        return (_a = this.client) === null || _a === void 0 ? void 0 : _a.sendMessagePromise(data);
    }
}
_Websocket_config = new WeakMap(), _Websocket_eventBus = new WeakMap(), _Websocket_servicesLoaded = new WeakMap(), _Websocket_statesLoaded = new WeakMap(), _Websocket_stopHeartbeat = new WeakMap(), _Websocket_subscribedEvents = new WeakMap(), _Websocket_unsubCallback = new WeakMap(), _Websocket_instances = new WeakSet(), _Websocket_emitEvent = function _Websocket_emitEvent(event, data) {
    return __classPrivateFieldGet(this, _Websocket_eventBus, "f").emit(event, data);
}, _Websocket_checkUserType = async function _Websocket_checkUserType() {
    const user = await this.getUser();
    if (user.is_admin === false) {
        this.connectionState = const_1.STATE_ERROR;
        this.client.close();
        throw new Error(globals_1.RED._('home-assistant.error.user_not_admin'));
    }
}, _Websocket_clientEvents = function _Websocket_clientEvents() {
    // Client events
    this.client.addEventListener('ready', this.onClientOpen.bind(this));
    this.client.addEventListener('disconnected', this.onClientClose.bind(this));
    this.client.addEventListener('reconnect-error', this.onClientError.bind(this));
}, _Websocket_subscribeEntityRegistry = function _Websocket_subscribeEntityRegistry() {
    if ((0, createSocket_1.atLeastHaVersion)(this.client.haVersion, 2023, 3)) {
        (0, collections_1.subscribeEntityRegistryDisplay)(this.client, (entityReg) => {
            const entities = entityReg.entities.map((entity) => {
                return {
                    entity_id: entity.ei,
                    device_id: entity.di,
                    area_id: entity.ai,
                    platform: entity.pl,
                    entity_category: entity.ec !== undefined
                        ? entityReg.entity_categories[entity.ec]
                        : undefined,
                    name: entity.en,
                    config_entry_id: undefined,
                    disabled_by: undefined,
                    icon: undefined,
                };
            });
            this.entities = entities;
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.HA_EVENT_REGISTRY_UPDATED, {
                devices: this.devices,
                entities: this.entities,
            });
        });
    }
    else {
        (0, collections_1.subscribeEntityRegistry)(this.client, (entities) => {
            this.entities = entities;
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.HA_EVENT_REGISTRY_UPDATED, {
                devices: this.devices,
                entities: this.entities,
            });
        });
    }
}, _Websocket_haEvents = async function _Websocket_haEvents() {
    // Home Assistant Events
    await this.client.subscribeEvents((evt) => __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_integrationEvent).call(this, evt), const_1.HA_EVENT_INTEGRATION);
    (0, home_assistant_js_websocket_1.subscribeConfig)(this.client, (config) => this.onClientConfigUpdate(config));
    (0, home_assistant_js_websocket_1.subscribeEntities)(this.client, this.onClientStates.bind(this));
    (0, home_assistant_js_websocket_1.subscribeServices)(this.client, this.onClientServices.bind(this));
    (0, collections_1.subscribeAreaRegistry)(this.client, (areas) => {
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.HA_EVENT_AREA_REGISTRY_UPDATED, areas);
        this.areas = areas;
    });
    (0, collections_1.subscribeDeviceRegistry)(this.client, (devices) => {
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.HA_EVENT_DEVICE_REGISTRY_UPDATED, devices);
        this.devices = devices;
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.HA_EVENT_REGISTRY_UPDATED, {
            devices: this.devices,
            entities: this.entities,
        });
    });
    __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_subscribeEntityRegistry).call(this);
}, _Websocket_onHomeAssistantRunning = function _Websocket_onHomeAssistantRunning() {
    if (!this.isHomeAssistantRunning) {
        this.isHomeAssistantRunning = true;
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, 'ha_client:running');
        if (this.integrationVersion === const_1.NO_VERSION) {
            this.createIntegrationEvent(const_1.INTEGRATION_NOT_LOADED);
        }
    }
}, _Websocket_integrationEvent = function _Websocket_integrationEvent(evt) {
    var _a, _b;
    const oldVersion = this.integrationVersion;
    switch ((_a = evt === null || evt === void 0 ? void 0 : evt.data) === null || _a === void 0 ? void 0 : _a.type) {
        case const_1.INTEGRATION_LOADED:
            this.integrationVersion = evt.data.version;
            break;
        case const_1.INTEGRATION_UNLOADED:
            this.integrationVersion = const_1.NO_VERSION;
            break;
        case const_1.INTEGRATION_NOT_LOADED:
            __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.INTEGRATION_EVENT, evt.data.type);
            return;
    }
    if (oldVersion !== this.integrationVersion) {
        __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_emitEvent).call(this, const_1.INTEGRATION_EVENT, (_b = evt === null || evt === void 0 ? void 0 : evt.data) === null || _b === void 0 ? void 0 : _b.type);
    }
};
exports.default = Websocket;
