"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _CurrentStateController_instances, _CurrentStateController_comparatorService, _CurrentStateController_homeAssistant, _CurrentStateController_transformState, _CurrentStateController_checkForDuration, _CurrentStateController_getForDurationMs;
Object.defineProperty(exports, "__esModule", { value: true });
const InputOutputController_1 = __importDefault(require("../../common/controllers/InputOutputController"));
const InputError_1 = __importDefault(require("../../common/errors/InputError"));
const TransformState_1 = require("../../common/TransformState");
const const_1 = require("../../const");
const mustache_1 = require("../../helpers/mustache");
const utils_1 = require("../../helpers/utils");
class CurrentStateController extends InputOutputController_1.default {
    constructor(params) {
        super(params);
        _CurrentStateController_instances.add(this);
        _CurrentStateController_comparatorService.set(this, void 0);
        _CurrentStateController_homeAssistant.set(this, void 0);
        _CurrentStateController_transformState.set(this, void 0);
        __classPrivateFieldSet(this, _CurrentStateController_comparatorService, params.comparatorService, "f");
        __classPrivateFieldSet(this, _CurrentStateController_homeAssistant, params.homeAssistant, "f");
        __classPrivateFieldSet(this, _CurrentStateController_transformState, params.transformState, "f");
    }
    async onInput({ message, parsedMessage, send, done, }) {
        const entityId = (0, mustache_1.renderTemplate)(parsedMessage.entityId.value, message, this.node.context(), __classPrivateFieldGet(this, _CurrentStateController_homeAssistant, "f").websocket.getStates());
        const entity = __classPrivateFieldGet(this, _CurrentStateController_homeAssistant, "f").websocket.getStates(entityId);
        if (!entity) {
            throw new InputError_1.default(`Entity could not be found in cache for entityId: ${entityId}`, 'not found');
        }
        entity.timeSinceChangedMs =
            Date.now() - new Date(entity.last_changed).getTime();
        if (this.node.config.state_type !== TransformState_1.TransformType.String) {
            // Convert and save original state if needed
            entity.original_state = entity.state;
            entity.state = __classPrivateFieldGet(this, _CurrentStateController_transformState, "f").transform(this.node.config.state_type, entity.state);
        }
        let isIfState = await __classPrivateFieldGet(this, _CurrentStateController_comparatorService, "f").getComparatorResult(this.node.config.halt_if_compare, this.node.config.halt_if, entity.state, this.node.config.halt_if_type, {
            message,
            entity,
        });
        if (__classPrivateFieldGet(this, _CurrentStateController_instances, "m", _CurrentStateController_checkForDuration).call(this, isIfState)) {
            const forDurationMs = await __classPrivateFieldGet(this, _CurrentStateController_instances, "m", _CurrentStateController_getForDurationMs).call(this, message);
            if (forDurationMs > 0) {
                isIfState = entity.timeSinceChangedMs > forDurationMs;
            }
        }
        await this.setCustomOutputs(this.node.config.outputProperties, message, {
            config: this.node.config,
            entity,
            entityState: entity.state,
            triggerId: entityId,
        });
        if (this.node.config.halt_if && !isIfState) {
            this.status.setFailed(entity.state.toString());
            send([null, message]);
            done();
            return;
        }
        this.status.setSuccess(entity.state.toString());
        send([message, null]);
        done();
    }
}
_CurrentStateController_comparatorService = new WeakMap(), _CurrentStateController_homeAssistant = new WeakMap(), _CurrentStateController_transformState = new WeakMap(), _CurrentStateController_instances = new WeakSet(), _CurrentStateController_checkForDuration = function _CurrentStateController_checkForDuration(isIfState) {
    return (isIfState &&
        this.node.config.halt_if.length > 0 &&
        [
            const_1.ComparatorType.Is,
            const_1.ComparatorType.IsNot,
            const_1.ComparatorType.Includes,
            const_1.ComparatorType.DoesNotInclude,
        ].includes(this.node.config.halt_if_compare));
}, _CurrentStateController_getForDurationMs = async function _CurrentStateController_getForDurationMs(message) {
    if (this.node.config.for === '')
        return 0;
    const value = await this.typedInputService.getValue(this.node.config.for, this.node.config.forType, { message });
    if (isNaN(value) || value < 0) {
        throw new InputError_1.default(`Invalid for value: ${value}`, 'home-assistant.status.error');
    }
    return (0, utils_1.getTimeInMilliseconds)(value, this.node.config.forUnits);
};
exports.default = CurrentStateController;
