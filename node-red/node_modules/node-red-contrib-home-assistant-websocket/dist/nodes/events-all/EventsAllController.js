"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _EventsAll_instances, _EventsAll_eventData, _EventsAll_clientEvent;
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const ExposeAsMixin_1 = __importDefault(require("../../common/controllers/ExposeAsMixin"));
const OutputController_1 = __importDefault(require("../../common/controllers/OutputController"));
const ConfigError_1 = __importDefault(require("../../common/errors/ConfigError"));
const Websocket_1 = require("../../homeAssistant/Websocket");
const _1 = require(".");
const ExposeAsController = (0, ExposeAsMixin_1.default)((OutputController_1.default));
class EventsAll extends ExposeAsController {
    constructor(props) {
        super(props);
        _EventsAll_instances.add(this);
        _EventsAll_eventData.set(this, void 0);
        try {
            if (this.node.config.eventData) {
                __classPrivateFieldSet(this, _EventsAll_eventData, JSON.parse(this.node.config.eventData), "f");
            }
        }
        catch (e) {
            throw new ConfigError_1.default('server-events.error.invalid_json');
        }
    }
    async onHaEventsAll(evt) {
        if (this.isEnabled === false)
            return;
        if (!this.homeAssistant.isHomeAssistantRunning &&
            this.node.config.waitForRunning === true) {
            return;
        }
        // Compare event data
        if (__classPrivateFieldGet(this, _EventsAll_eventData, "f") && !(0, lodash_1.isMatch)(evt.event, __classPrivateFieldGet(this, _EventsAll_eventData, "f")))
            return;
        const message = {};
        await this.setCustomOutputs(this.node.config.outputProperties, message, {
            config: this.node.config,
            eventData: evt,
        });
        this.status.setSuccess(evt.event_type);
        this.node.send(message);
    }
    onHaEventsClose() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'disconnected');
    }
    onHaEventsOpen() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'connected');
    }
    onHaEventsConnecting() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'connecting');
    }
    onHaEventsRunning() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'running');
    }
    onHaEventsReady() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'ready');
    }
    onHaEventsError(err) {
        if (err) {
            __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'error', err.message);
        }
    }
    onClientStatesLoaded() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'states_loaded');
    }
    onClientServicesLoaded() {
        __classPrivateFieldGet(this, _EventsAll_instances, "m", _EventsAll_clientEvent).call(this, 'services_loaded');
    }
}
_EventsAll_eventData = new WeakMap(), _EventsAll_instances = new WeakSet(), _EventsAll_clientEvent = function _EventsAll_clientEvent(type, data) {
    if (this.isEnabled === false)
        return;
    if (this.node.config.eventType === '' ||
        this.node.config.eventType === _1.HA_CLIENT) {
        this.node.send({
            event_type: _1.HA_CLIENT,
            topic: `${_1.HA_CLIENT}:${type}`,
            payload: type,
            data,
        });
        if (type === Websocket_1.ClientEvent.StatesLoaded ||
            type === Websocket_1.ClientEvent.ServicesLoaded) {
            this.status.setSuccess(type);
        }
    }
};
exports.default = EventsAll;
