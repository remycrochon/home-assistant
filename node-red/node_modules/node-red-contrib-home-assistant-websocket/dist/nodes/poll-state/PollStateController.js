"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _PollStateController_instances, _PollStateController_comparatorService, _PollStateController_timer, _PollStateController_transformState, _PollStateController_updateinterval, _PollStateController_getInterval;
Object.defineProperty(exports, "__esModule", { value: true });
const ExposeAsMixin_1 = __importDefault(require("../../common/controllers/ExposeAsMixin"));
const OutputController_1 = __importDefault(require("../../common/controllers/OutputController"));
const ConfigError_1 = __importDefault(require("../../common/errors/ConfigError"));
const inputErrorHandler_1 = require("../../common/errors/inputErrorHandler");
const TransformState_1 = require("../../common/TransformState");
const const_1 = require("../../const");
const utils_1 = require("../../helpers/utils");
const ExposeAsController = (0, ExposeAsMixin_1.default)((OutputController_1.default));
class PollStateController extends ExposeAsController {
    constructor(props) {
        super(props);
        _PollStateController_instances.add(this);
        _PollStateController_comparatorService.set(this, void 0);
        _PollStateController_timer.set(this, void 0);
        _PollStateController_transformState.set(this, void 0);
        _PollStateController_updateinterval.set(this, void 0);
        __classPrivateFieldSet(this, _PollStateController_comparatorService, props.comparatorService, "f");
        __classPrivateFieldSet(this, _PollStateController_transformState, props.transformState, "f");
    }
    onClose() {
        if (__classPrivateFieldGet(this, _PollStateController_timer, "f")) {
            clearInterval(__classPrivateFieldGet(this, _PollStateController_timer, "f"));
            __classPrivateFieldSet(this, _PollStateController_timer, undefined, "f");
        }
    }
    getNodeEntityId() {
        return this.node.config.entityId;
    }
    async onTimer() {
        if (this.isEnabled === false) {
            return;
        }
        const entity = this.homeAssistant.websocket.getStates(this.node.config.entityId);
        if (!entity) {
            throw new ConfigError_1.default([
                'poll-state.error.entity_id_not_found',
                { entity_id: this.node.config.entityId },
            ]);
        }
        entity.timeSinceChangedMs =
            Date.now() - new Date(entity.last_changed).getTime();
        if (this.node.config.stateType !== TransformState_1.TransformType.String) {
            // Convert and save original state if needed
            entity.original_state = entity.state;
            entity.state = __classPrivateFieldGet(this, _PollStateController_transformState, "f").transform(this.node.config.stateType, entity.state);
        }
        const isIfState = await __classPrivateFieldGet(this, _PollStateController_comparatorService, "f").getComparatorResult(this.node.config.ifStateOperator, this.node.config.ifState, entity.state, this.node.config.ifStateType, {
            entity,
        });
        const message = {};
        await this.setCustomOutputs(this.node.config.outputProperties, message, {
            config: this.node.config,
            entity,
            entityState: entity.state,
            triggerId: this.node.config.entityId,
        });
        const statusMessage = `${entity.state}`;
        // Check 'if state' and send to correct output
        if (this.node.config.ifState && !isIfState) {
            this.status.setFailed(statusMessage);
            this.node.send([null, message]);
            return;
        }
        this.status.setSuccess(statusMessage);
        this.node.send([message, null]);
    }
    async onIntervalUpdate() {
        const interval = await __classPrivateFieldGet(this, _PollStateController_instances, "m", _PollStateController_getInterval).call(this);
        // create new timer if interval changed
        if (interval !== __classPrivateFieldGet(this, _PollStateController_updateinterval, "f")) {
            clearInterval(__classPrivateFieldGet(this, _PollStateController_timer, "f"));
            __classPrivateFieldSet(this, _PollStateController_updateinterval, interval, "f");
            __classPrivateFieldSet(this, _PollStateController_timer, setInterval(async () => {
                await this.onTimer().catch((e) => {
                    const { error, statusMessage } = (0, inputErrorHandler_1.getErrorData)(e);
                    this.status.setError(statusMessage);
                    this.node.error(error);
                });
            }, __classPrivateFieldGet(this, _PollStateController_updateinterval, "f")), "f");
        }
    }
}
_PollStateController_comparatorService = new WeakMap(), _PollStateController_timer = new WeakMap(), _PollStateController_transformState = new WeakMap(), _PollStateController_updateinterval = new WeakMap(), _PollStateController_instances = new WeakSet(), _PollStateController_getInterval = async function _PollStateController_getInterval() {
    let interval = this.node.config.updateInterval || '0';
    if (this.node.config.updateIntervalType === const_1.TypedInputTypes.JSONata) {
        interval = await this.jsonataService.evaluate(interval);
    }
    const intervalMs = (0, utils_1.getTimeInMilliseconds)(Number(interval), this.node.config.updateIntervalUnits);
    if (isNaN(intervalMs)) {
        throw new ConfigError_1.default([
            'poll-state.error.interval_not_a_number',
            { interval },
        ]);
    }
    return Number(intervalMs);
};
exports.default = PollStateController;
